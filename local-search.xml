<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/01/hello-world/"/>
    <url>/2022/03/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2021/07/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/07/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p><h2 id="为什么要学习函数式编程"><a href="#为什么要学习函数式编程" class="headerlink" title="为什么要学习函数式编程"></a>为什么要学习函数式编程</h2><p>函数式编程是非常古老的一个概念，早于计算机的出生。</p><p>那我们为什么现在还要学习函数式编程呢？</p><ul><li>函数式编程随着 React 的流行受到越来越多的关注</li><li>Vue3 也开始拥抱函数式编程</li><li>函数式编程可以抛弃 this</li><li>打包过程中可以更好的利用 tree shaking 过滤无用代码</li><li>方便测试、并行处理等</li><li>有很多库可以帮我们进行函数式开发：lodash、underscore、ramda</li></ul><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>函数式编程(Functional Programming, FP), FP 是编程规范之一，我们常听说的编程范式还有面向过程编程、面向对象编程。</p><ul><li>面向对象编程思维：把现实世界中的事物抽象成程序世界中的对象和类，通过封装、继承和多态来演示事物事件的联系</li><li>函数式编程思维: 把现实世界的事物和事物之间的<strong>联系</strong>抽象到程序世界 (对运算过程进行抽象)<ul><li>程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数</li><li>x -&gt; y (联系、映射) -&gt; y, y &#x3D; f(x)</li><li><strong>函数式编程中的函数指的不是程序中的函数(方法)<strong>，而是数学中的函数即映射关系，例如：</strong>y &#x3D; sin(x)</strong>, x 和 y 的关系</li><li>相同的输入始终要得到相同的输出(纯函数)</li><li>函数式编程用来描述数据(函数)之间的映射</li></ul></li></ul><p>非函数式编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span> sum = num1 + num2;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br></code></pre></td></tr></table></figure><p>函数式-抽象了运算的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (n1, n2) &#123;<br>  <span class="hljs-keyword">return</span> n1 + n2;<br>&#125;<br><span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br></code></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>函数是头等函数</li><li>高阶函数</li><li>闭包</li></ul><h3 id="函数是头等函数"><a href="#函数是头等函数" class="headerlink" title="函数是头等函数"></a>函数是头等函数</h3><ul><li>函数可以存储在变量中</li><li>函数可以作为参数</li><li>函数可以作为返回值</li></ul><p>在 JavaScript 中<strong>函数就是一个普通的对象</strong>(可以通过 new Function())，我们可以把函数存储到变量&#x2F;数组中，它还可以作为另一个函数的参数和返回值，<br>甚至我们可以在运行程序的时候通过 new Function(‘alert(1)’) 来构造一个新的函数。</p><ul><li>把函数赋值给变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把函数赋值给变量</span><br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello First-class Function&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// 一个示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogController</span> = &#123;<br>  index (posts) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Views</span>.<span class="hljs-title function_">index</span>(posts) &#125;,<br>  show (posts) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Views</span>.<span class="hljs-title function_">show</span>(posts) &#125;,<br>  create (attrs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">create</span>(attrs) &#125;,<br>  update (posts, attrs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">update</span>(posts, attrs) &#125;,<br>  destroy (posts) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">destroy</span>(posts) &#125;,<br>&#125;<br><br><span class="hljs-comment">// 优化</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogController</span> = &#123;<br>  <span class="hljs-attr">index</span>: <span class="hljs-title class_">Views</span>.<span class="hljs-property">index</span>,<br>  <span class="hljs-attr">show</span>: <span class="hljs-title class_">Views</span>.<span class="hljs-property">show</span>,<br>  <span class="hljs-attr">create</span>: <span class="hljs-title class_">Db</span>.<span class="hljs-property">create</span>,<br>  <span class="hljs-attr">update</span>: <span class="hljs-title class_">Db</span>.<span class="hljs-property">update</span>,<br>  <span class="hljs-attr">destroy</span>: <span class="hljs-title class_">Db</span>.<span class="hljs-property">destroy</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>什么是高阶函数</p><ul><li><p>高阶函数(Higher-order function) HOF</p><ul><li>可以把函数作为参数传递给另个一个函数</li><li>可以把函数作为另一个函数的返回结果</li></ul><p>-函数作为参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟 forEach</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">forEach</span> (array, fn) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-title function_">fn</span>(array[i]);<br>  &#125;<br>&#125;<br>  <br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>  <br><span class="hljs-title function_">forEach</span>(array, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;)<br>  <br><span class="hljs-comment">// 模拟 filter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">array, fn</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++ ) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">fn</span>(array[i])) &#123;<br>      result.<span class="hljs-title function_">push</span>(array[i]);<br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br>  <br><span class="hljs-keyword">let</span> newArray = <span class="hljs-title function_">filter</span>(array, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;)<br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArray)<br></code></pre></td></tr></table></figure></li><li><p>作为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// once 只执行一次的函数，当前使用场景为支付</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span> (fn) &#123;<br>   <span class="hljs-keyword">let</span> done = <span class="hljs-literal">false</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...rest</span>) &#123;<br>     <span class="hljs-keyword">if</span>(!done) &#123;<br>       done = <span class="hljs-literal">true</span><br>       fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, rest)<br>     &#125;<br>   &#125;<br> &#125;<br> <br> <span class="hljs-keyword">let</span> pay = <span class="hljs-title function_">once</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">money</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我支付了￥<span class="hljs-subst">$&#123;money&#125;</span> RMB`</span>)<br> &#125;)<br><br> <span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>)<br> <span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>)<br> <span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure></li><li><p>高阶函数的意义</p><ul><li>抽象可以帮助我们屏蔽细节，只需要关注于我们的目标</li><li>高阶函数是用来抽象通用的问题<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 面向过程的方式</span><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i ++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[i])<br>&#125;<br>  <br><span class="hljs-comment">// 高阶函数</span><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-title function_">forEach</span>(array, <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;)<br>  <br><span class="hljs-keyword">let</span> r = <span class="hljs-title function_">filter</span>(array, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>&#125;)<br>  <br></code></pre></td></tr></table></figure></li></ul></li><li><p>常用的高阶函数</p><ul><li>数组方法<ul><li><code>forEach、map、filter、every、some、find/finedIndex、reduce、sort...</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟 map 方法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">map</span> = (<span class="hljs-params">array, fn</span>) =&gt; &#123;<br>   <span class="hljs-keyword">let</span> results = []<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> array) &#123;<br>     results.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(value))<br>   &#125;<br>   <span class="hljs-keyword">return</span> results;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr = <span class="hljs-title function_">map</span>(arr, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * item)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br><br><span class="hljs-comment">// every 是否都匹配指定的条件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">every</span> = (<span class="hljs-params">array,fn</span>) =&gt; &#123;<br>   <span class="hljs-keyword">let</span> status = <span class="hljs-literal">true</span><br>   <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">fn</span>(item)) &#123;<br>      status = <span class="hljs-literal">false</span><br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>   <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">every</span>(array, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">10</span>)<br><span class="hljs-comment">// console.log(state)</span><br><br><span class="hljs-comment">// some 数组中是否有一个满足指定的条件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">some</span> = (<span class="hljs-params">array, fn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> status = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">fn</span>(item)) &#123;<br>      status = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> status<br>&#125;<br><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>,<span class="hljs-number">7</span>, <span class="hljs-number">15</span>]<br><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">some</span>(array, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>闭包(Closure): 函数和其周围的状态（语法环境）的引用捆绑在一起形成的闭包。</li><li>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数作为返回值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;Hello function&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">makeFn</span>()<br><span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// once 只被执行一次</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">once</span> = (<span class="hljs-params">fn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> done = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...rest</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!done) &#123;<br>      done = <span class="hljs-literal">true</span><br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, rest)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> pay = <span class="hljs-title function_">once</span>(<span class="hljs-function"><span class="hljs-params">money</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`成功支付￥<span class="hljs-subst">$&#123;money&#125;</span> RMB`</span>)<br>&#125;)<br><span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>);<br><span class="hljs-title function_">pay</span>(<span class="hljs-number">5</span>);<br><br></code></pre></td></tr></table></figure></li><li>闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移出，但是<strong>栈上的作用域成员因为被外部引用，所以不能释放</strong>，因此内部函数依然可以访问外部函数的成员</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算幂</span><br></code></pre></td></tr></table></figure><h2 id="纯函数-Pure-functions"><a href="#纯函数-Pure-functions" class="headerlink" title="纯函数 Pure functions"></a>纯函数 Pure functions</h2><ul><li><strong>相同的输入永远会得到相同的输出</strong>，而且没有任何可观察的副作用</li><li>纯函数就是类数学中的函数(用来描述输入和输出之间的关系)，y &#x3D; f(x)</li><li>lodash 是一个纯函数的功能库，提供了对数组、数字、字符串和函数等操作的一些方法</li><li>数组中的 <code>slice</code> 和 <code>splice</code> 分别是纯函数和非纯函数<ul><li><code>slice</code> 返回数组中指定的部分，不会改变原数组</li><li><code>splice</code> 对数组进行操作返回该数组，会改变原数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-comment">//纯函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 1, 2 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 1, 2 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 1, 2 ]</span><br><br><span class="hljs-comment">//非纯函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 1, 2 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 3, 4 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// [ 5, 6 ]</span><br></code></pre></td></tr></table></figure></li></ul></li><li>函数式编程不会保留计算中间的结果，所以变量是不可以变的(无状态的)</li><li>我们可以把一个函数的执行结果交给另一个函数去处理</li></ul><h3 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 演示 lodash - first / last / toUpper / reverse / each / includes / find / findIndex</span><br><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-string">&#x27;kate&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">first</span>(array))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">last</span>(array))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">toUpper</span>(_.<span class="hljs-title function_">first</span>(array)))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">reverse</span>(array))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">each</span>(array, <span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index)<br>&#125;))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">includes</span>(array, <span class="hljs-string">&#x27;jack&#x27;</span>))<br><span class="hljs-comment">// console.log(_.find(array, &#x27;jack&#x27;))</span><br><span class="hljs-comment">// console.log(_.includes(array, &#x27;jack&#x27;))</span><br></code></pre></td></tr></table></figure><h3 id="纯函数的优势"><a href="#纯函数的优势" class="headerlink" title="纯函数的优势"></a>纯函数的优势</h3><ul><li><p>可缓存：</p><ul><li>因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span> (r) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r * r<br>&#125;<br><span class="hljs-keyword">let</span> getAreaWithMemory = _.<span class="hljs-title function_">memoize</span>(getArea)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 4 只打印了一次，第一次之后直接从缓存中读取</span><br><span class="hljs-comment"> 50.26548245743669</span><br><span class="hljs-comment"> 50.26548245743669</span><br><span class="hljs-comment"> 50.26548245743669</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>模拟 memoize 的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">let</span> cache = &#123;&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...area</span>) &#123;<br>    <span class="hljs-keyword">let</span> key = <span class="hljs-string">`<span class="hljs-subst">$&#123;area&#125;</span>`</span><br>    cache[key] = cache[key] || <span class="hljs-title function_">fn</span>(...area)<br>    <span class="hljs-keyword">return</span> cache[key]<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span> (r) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r * r<br>&#125;<br><span class="hljs-keyword">let</span> getAreaWithMemory = <span class="hljs-title function_">memoize</span>(getArea)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getAreaWithMemory</span>(<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>可测试：</p><ul><li>纯函数让测试更方便</li></ul></li><li><p>并行处理：</p><ul><li>在多线程环境下并行操作共享的内存数据很可能出现意外情况</li><li>纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker 可以开启多线程)</li></ul></li></ul><h3 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h3><ul><li>纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的<strong>副作用</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非纯函数</span><br><span class="hljs-keyword">let</span> min = <span class="hljs-number">18</span> <span class="hljs-comment">// mini 是外部可变的，所以影响了纯函数的原则</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span> (age) &#123;<br>  <span class="hljs-keyword">return</span> age &gt;= min;<br>&#125;<br><br><span class="hljs-comment">// 纯函数(有硬编码，后续可以通过柯里化解决)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span> (age) &#123;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-number">18</span><br>  <span class="hljs-keyword">return</span> age &gt;= min<br>&#125;<br></code></pre></td></tr></table></figure>副作用让一个函数变得不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖外部状态就无法保证相同输出，就会带来副作用</li></ul><p>大部分的副作用来源于：</p><ul><li>配置文件</li><li>数据库</li><li>获取用户输入</li><li>……<br>所有的外部交互都有可能代理副作用，副作用也使得方法的通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患和不确定性</li></ul><h2 id="柯里化-Haskell-Brooks-Curry"><a href="#柯里化-Haskell-Brooks-Curry" class="headerlink" title="柯里化 Haskell Brooks Curry"></a>柯里化 Haskell Brooks Curry</h2><p>使用柯里化解决程序中硬编码问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span> (age) &#123;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-number">18</span><br>  <span class="hljs-keyword">return</span> age &gt;= min<br>&#125;<br><br><span class="hljs-comment">// 普通的纯函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span>(<span class="hljs-params">min, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> age &gt;= min<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkAge</span>(<span class="hljs-number">18</span>, <span class="hljs-number">20</span>))<br><br><span class="hljs-comment">// 柯里化纯函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span> (min) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">age</span>) &#123;<br>    <span class="hljs-keyword">return</span> age &gt;= min<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//  柯里化ES6写法</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">checkAge</span> = min =&gt; (<span class="hljs-function"><span class="hljs-params">age</span> =&gt;</span> age &gt;= min)<br><br><span class="hljs-keyword">const</span> checkAge18 = <span class="hljs-title function_">checkAge</span>(<span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkAge18</span>(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">const</span> checkAge20 = <span class="hljs-title function_">checkAge</span>(<span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkAge20</span>(<span class="hljs-number">18</span>))<br></code></pre></td></tr></table></figure><ul><li>柯里化<ul><li>当函数有多个参数需要传递的时候先传递一部分调用它(这部分参数以后永远不变)</li><li>然后返回一个新函数接收剩余参数，返回结果</li></ul></li></ul><h3 id="lodash-中的柯里化"><a href="#lodash-中的柯里化" class="headerlink" title="lodash 中的柯里化"></a>lodash 中的柯里化</h3><ul><li><code>_.curry(func)</code><ul><li>功能：创建一个函数，该函数接收一个或多个func的参数，如果 func 所需参数都被传入，则会立即执行并返回结果。如果传递的参数这是 func 所需参数的一部分，那它会返回一个函数用来接收剩余参数</li><li>参数：需要柯里化的函数</li><li>返回值：柯里化后的函数</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">a, b, c</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><span class="hljs-keyword">let</span> getSumCurried = _.<span class="hljs-title function_">curry</span>(getSum)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSumCurried</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))  <span class="hljs-comment">// 传递所有参数时，会立即调用并返回结果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSumCurried</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">// 如果传递的并不是该函数的所有参数，那它会返回一个函数等待接收剩下的参数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSumCurried</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getSumCurried</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))<br><br></code></pre></td></tr></table></figure><ul><li><p>学习案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\+/g</span>))<br><br><span class="hljs-keyword">let</span> match = _.<span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">reg, str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">match</span>(reg)<br>&#125;)<br><br><span class="hljs-keyword">const</span> haveSpace = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\s+/g</span>)<br><span class="hljs-keyword">const</span> haveNumber = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/g</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">haveSpace</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">haveNumber</span>(<span class="hljs-string">&#x27;123abc&#x27;</span>))<br><br><span class="hljs-keyword">const</span> filter = _.<span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fn, array</span>) &#123;<br>  <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">filter</span>(fn)<br>&#125;)<br><br><span class="hljs-keyword">let</span> haveSpaceFn = <span class="hljs-title function_">filter</span>(haveSpace);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">haveSpaceFn</span>([<span class="hljs-string">&#x27;gu1 yun&#x27;</span>, <span class="hljs-string">&#x27;ho_wei&#x27;</span>]))<br></code></pre></td></tr></table></figure></li><li><p>总结<br>柯里化的操是将函数的参数先传递一本分给函数，剩下的参数传递给返回的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> haveSpace = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\s+/g</span>)<br><span class="hljs-keyword">const</span> haveNumber = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/g</span>)<br><br><span class="hljs-comment">// 自己通过柯里化改造函数</span><br><span class="hljs-keyword">const</span> filter = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// fn: 使用的工具函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-comment">// array: 需要使用到的数据</span><br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">filter</span>(fn)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> haveSpaceCurry = <span class="hljs-title function_">filter</span>(haveSpace)<br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">filter</span> = fn =&gt; (<span class="hljs-function"><span class="hljs-params">array</span> =&gt;</span> array.<span class="hljs-title function_">filter</span>(fn))<br><br><span class="hljs-comment">// lodash 提供的柯里化方法</span><br><span class="hljs-keyword">const</span> filter = _.<span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fn, array</span>) &#123;<br>  <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">filter</span>(fn)<br>&#125;)<br><span class="hljs-comment">// lodash 的 curry 方法可以吧一个普通的函数编程柯里化函数</span><br><span class="hljs-comment">// 最终的目标是将函数变成一元函数</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="柯里化实现原理"><a href="#柯里化实现原理" class="headerlink" title="柯里化实现原理"></a>柯里化实现原理</h3><p>模拟实现 lodash 中的 curry 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span> (a, b, c) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span> (fn) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curriedFn</span> (...args) &#123;<br>    <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span> &lt; fn.<span class="hljs-property">length</span> ) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">curriedFn</span>(...args.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">form</span>(<span class="hljs-variable language_">arguments</span>)))        <br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> curried = <span class="hljs-title function_">curry</span>(getSum)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curried</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h3 id="柯里化总结"><a href="#柯里化总结" class="headerlink" title="柯里化总结"></a>柯里化总结</h3><ul><li>柯里化可以我们给一个函数传递较少的参数，得到一个已经记录了某个固定参数的新函数</li><li>这是一种函数对参数的缓存</li><li>让函数变得更灵活，让函数的颗粒度更小</li><li>可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能</li></ul><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>使用纯函数和柯里化很容易写出洋葱代码 <code>a(b(c(d)))</code></p><ul><li>获取数组的最后一个元素再转换成大写字母 <code>_.toUpper(_.first(_.reverse(array)))</code><br>函数组合可以让我们把细粒度的函数重新组合成一个新的函数</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>下面这张图表示程序中使用函数处理数据的过程，给 n 函数输入参数 a，返回结果 b,可以想想 a 通过一个管道得到了 b 的数据</p><img src="/2021/07/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/img.png" class=""><p>当fn比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。</p><p>下面这张图可以想象成把 fn 这个管道拆分成3个管道 f1 f2 f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b</p><img src="/2021/07/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/img_1.png" class=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn = <span class="hljs-title function_">compose</span>(f1, f2, f3)<br>b = <span class="hljs-title function_">fn</span>(a)<br></code></pre></td></tr></table></figure><p><code>commpose</code> 就相当于是一个管道，它把三个函数组合成一个函数<code>fn</code>，调用 <code>fn</code> 返回结果<code>b</code>，实际上这个数据是由<code>f1、f2、f3</code>三个函数处理的，在它们处理时就会产生<code>m、n</code>等结果，对于这些结果我们并不需要关心</p><h3 id="函数组合-1"><a href="#函数组合-1" class="headerlink" title="函数组合"></a>函数组合</h3><ul><li>函数组合 (Compose): 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的处理函数合并成一个函数<ul><li>函数就是处理数据的管道，函数组合就是把这些管道链接，让数据穿过多个管道得到最终的结果</li><li><strong>函数组合默认是从右到左执行</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  函数组合</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">f, g</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">g</span>(value))<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reverse</span>()<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> last = <span class="hljs-title function_">compose</span>(first, reverse)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">last</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="lodash-中的组合函数"><a href="#lodash-中的组合函数" class="headerlink" title="lodash 中的组合函数"></a>lodash 中的组合函数</h3><p>lodash 中组合函数 <code>flow()</code> 或者 <code>flowRight()</code>，它们都可以组合多个函数</p><ul><li><code>flow()</code>从左到右执行</li><li><code>flowRight()</code>从右到左执行(常用)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reverse</span> = array =&gt; array.<span class="hljs-title function_">reverse</span>()<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = array =&gt; array[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpper</span> = value =&gt;  value.<span class="hljs-title function_">toUpperCase</span>()<br><br><span class="hljs-keyword">const</span> f = _.<span class="hljs-title function_">flowRight</span>(toUpper, first, reverse)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(arr)) <span class="hljs-comment">// D</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="组合函数的实现原理"><a href="#组合函数的实现原理" class="headerlink" title="组合函数的实现原理"></a>组合函数的实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reverse</span> = array =&gt; array.<span class="hljs-title function_">reverse</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = array =&gt; array[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpper</span> = value =&gt;  value.<span class="hljs-title function_">toUpperCase</span>()<br><br><span class="hljs-comment">// 使用 lodash 中的组合函数</span><br><span class="hljs-keyword">const</span> f = _.<span class="hljs-title function_">flowRight</span>(toUpper, first, reverse)<br><br><span class="hljs-comment">// --------------------------------------------------------------------</span><br><br><span class="hljs-comment">// 自定义组合函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (...args) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">count, fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(count), value)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// es6 版本</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> args.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(acc), value)<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-title function_">compose</span>(toUpper, first, reverse)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(arr)) <span class="hljs-comment">// E</span><br></code></pre></td></tr></table></figure><h2 id="组合律"><a href="#组合律" class="headerlink" title="组合律"></a>组合律</h2><p>函数组合要满足**组合率(associativity)**，我们可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组合律 (associativity)</span><br><span class="hljs-keyword">let</span> f = <span class="hljs-title function_">compose</span>(f, g, h)<br><span class="hljs-keyword">let</span> associactive = <span class="hljs-title function_">compose</span>(<span class="hljs-title function_">compose</span>(f, g), h) == <span class="hljs-title function_">compose</span>(f, <span class="hljs-title function_">compose</span>(g, h)) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// --------------------------------------------------------------------</span><br><br><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reverse</span> = array =&gt; array.<span class="hljs-title function_">reverse</span>()<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = array =&gt; array[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpper</span> = value =&gt;  value.<span class="hljs-title function_">toUpperCase</span>()<br><br><span class="hljs-comment">// const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)</span><br><span class="hljs-keyword">const</span> f = _.<span class="hljs-title function_">flowRight</span>(_.<span class="hljs-property">toUpper</span>, _.<span class="hljs-title function_">flowRight</span>(_.<span class="hljs-property">first</span>, _.<span class="hljs-property">reverse</span>))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(arr ))<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>辅助函数来调试打印组合函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 将 NEVER SAY DIE 处理为 never-say-die</span><br><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">log</span> = v =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)<br>  <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-keyword">const</span> trace = _.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">tag, v</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tag, v)<br>  <span class="hljs-keyword">return</span> v<br>&#125;)<br><br><span class="hljs-comment">// 通过封装将这些函数变为一元函数</span><br><span class="hljs-keyword">const</span> split = _.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">sep, str</span>) =&gt;</span> _.<span class="hljs-title function_">split</span>(str, sep))<br><span class="hljs-keyword">const</span> map = _.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">fn, array</span>) =&gt;</span> _.<span class="hljs-title function_">map</span>(array, fn))<br><span class="hljs-keyword">const</span> join = _.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">sep, array</span>) =&gt;</span> _.<span class="hljs-title function_">join</span>(array, sep))<br><span class="hljs-comment">// 使用 log 辅助函数将当前进度时的值进行打印，但有一个问题是不能区分打印的具体位置</span><br><span class="hljs-comment">// const compose = _.flowRight(join(&#x27;-&#x27;),log, map(_.toLower),log, split(&#x27; &#x27;))</span><br><span class="hljs-keyword">const</span> compose = _.<span class="hljs-title function_">flowRight</span>(<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>),<span class="hljs-title function_">trace</span>(<span class="hljs-string">&#x27;这是 map 之后&#x27;</span>), <span class="hljs-title function_">map</span>(_.<span class="hljs-property">toLower</span>),<span class="hljs-title function_">trace</span>(<span class="hljs-string">&#x27;这是 split 之后&#x27;</span>), <span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">compose</span>(<span class="hljs-string">&#x27;NEVER SAY DIE&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="Lodash-中的-FP-Functional-Programming-模块"><a href="#Lodash-中的-FP-Functional-Programming-模块" class="headerlink" title="Lodash 中的 FP(Functional Programming) 模块"></a>Lodash 中的 FP(Functional Programming) 模块</h2><p>lodash&#x2F;fp</p><ul><li>lodash 的 fp 模块提供了实用的<strong>对函数式编程的友好</strong>的方法</li><li>提供了不可变的、已经被柯里化的且具有<strong>auto-curried、iteratee-first、data-list</strong>等特点的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// lodash 模块中的方法和 FP 模块中方法的区别</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-comment">//  lodash - 数据优先，回调、操作往后排</span><br><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br>_.<span class="hljs-title function_">map</span>(array, _.<span class="hljs-property">toUpper</span>) <span class="hljs-comment">// [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ]</span><br>_.<span class="hljs-title function_">map</span>(array) <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span><br>_.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// [ &#x27;hello&#x27;, &#x27;world&#x27; ]</span><br><br><span class="hljs-comment">// lodash/fp 模块 - 方法优先，已经是被柯里化的函数</span><br><span class="hljs-keyword">const</span> fp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br><br>fp.<span class="hljs-title function_">map</span>(fp.<span class="hljs-property">toUpper</span>, array)<br>fp.<span class="hljs-title function_">map</span>(fp.<span class="hljs-property">toUpper</span>)(array)<br><br>fp.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>)<br>fp.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><p>lodash 和 lodash&#x2F;fp 模块中 map 方法的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lodash 和 lodash/fp 模块中 map 方法的区别</span><br>  <span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><br>  <span class="hljs-keyword">const</span> array = [<span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>]<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">map</span>(array, <span class="hljs-built_in">parseInt</span>)) <span class="hljs-comment">// [ 23, NaN, 2 ]</span><br>  <span class="hljs-comment">// lodash 中 map 方法的parseInt回调会要求三个参数：当前处理元素：&#x27;23&#x27; 下标：&#x27;0&#x27; 集合：array</span><br><br>  <span class="hljs-keyword">const</span> fp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fp.<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>, array)) <span class="hljs-comment">// [ 23, 8, 10 ]</span><br>  <span class="hljs-comment">// fp 模块中的 map 方法的parseInt回调只要求一个当前处理元素的参数</span><br></code></pre></td></tr></table></figure><h2 id="PointFree"><a href="#PointFree" class="headerlink" title="PointFree"></a>PointFree</h2><p><strong>PointFree:</strong> 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数组的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数</p><ul><li>合并时不需要指明处理的数据</li><li><strong>只需要合成运算过程</strong></li><li>需要定义一些辅助的基本运算函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Point Free 模式其实就是函数的组合</span><br><span class="hljs-keyword">const</span> f = fp.<span class="hljs-title function_">flowRight</span>(fp.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>), fp.<span class="hljs-title function_">map</span>(fp.<span class="hljs-property">toLower</span>), fp.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>))<br></code></pre></td></tr></table></figure></li></ul><p>来吧，展示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把一个字符串中的首字母提取并转换为大写，使用&quot;.&quot;作为分隔符号</span><br><span class="hljs-comment">// world wild web ==&gt; W.W.W</span><br><span class="hljs-keyword">const</span> fp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br><span class="hljs-comment">// const firstLetterToUpper = fp.flowRight(fp.join(&#x27;.&#x27;), fp.map(fp.first), fp.map(fp.toUpper), fp.split(&#x27; &#x27;)) // 遍历两次</span><br><span class="hljs-keyword">const</span> firstLetterToUpper = fp.<span class="hljs-title function_">flowRight</span>(fp.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;.&#x27;</span>), fp.<span class="hljs-title function_">map</span>(fp.<span class="hljs-title function_">flowRight</span>(fp.<span class="hljs-property">first</span>, fp.<span class="hljs-property">toUpper</span>)), fp.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">firstLetterToUpper</span>(<span class="hljs-string">&#x27;world wild web&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h2><p>函子的作用是帮助我们将副作用控制在可控的范围内、异常处理、异步操作等。</p><h3 id="Functor-函子"><a href="#Functor-函子" class="headerlink" title="Functor 函子"></a>Functor 函子</h3><p>什么是 functor</p><ul><li>容器：包含值和值的变形关系(这个变形关系就是函数)</li><li>函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>  <span class="hljs-title function_">constructor</span> (value) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>(value)<br>  &#125;<br>  map (fn) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Container</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">5</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br><br><span class="hljs-keyword">let</span> upper = <span class="hljs-title class_">Container</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toUpperCase</span>()) <span class="hljs-comment">// 会报错，函子处理 null/undefined 等空值是会报错，需要使用 MayBe 函子来处理（下个小节）</span><br><br></code></pre></td></tr></table></figure></li><li>总结<ul><li>函数式编程的运算不直接操作值，而是由函子完成</li><li>函子就是一个实现了 map 的契约对象</li><li>我们可以把函子想象成一个盒子，这个盒子里封装了一个值</li><li>想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值得函数(纯函数)，由这个函数对这个值进行处理</li><li>最终 map 方法返回一个包含新值得盒子(函子)</li></ul></li></ul><h3 id="MayBe-函子"><a href="#MayBe-函子" class="headerlink" title="MayBe 函子"></a>MayBe 函子</h3><p>我们在编程过程中可能会遇到很多错误，需要对相应的错误做相应的处理，<code>MayBe</code> 函子的作用就是对外部的空值情况做处理(控制副作用在允许的范围内)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MayBe</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MayBe</span>(value)<br>    &#125;<br><br>    isNothing () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> === <span class="hljs-literal">undefined</span><br>    &#125;<br><br>    <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>() ? <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>) : <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// let r = MayBe.of(&#x27;hello&#x27;)</span><br>  <span class="hljs-comment">//   .map(x =&gt; x.toUpperCase())</span><br>  <span class="hljs-comment">// console.log(r) // 正常执行</span><br><br>  <span class="hljs-keyword">let</span> r = <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toUpperCase</span>())<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r) <span class="hljs-comment">// MayBe &#123; _value: null &#125; 传递 null 也不会报错</span><br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">let</span> r = <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toUpperCase</span>())<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-string">&#x27; world&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r) <span class="hljs-comment">// MayBe &#123; _value: null &#125;</span><br><br>  <span class="hljs-comment">// 返回值为null</span><br></code></pre></td></tr></table></figure><p>但其实还存在一个问题，当我们调用多个函子时，如果其中某一个位置发生了异常，是没有办法精确捕捉到的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MayBe</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MayBe</span>(value)<br>    &#125;<br><br>    isNothing () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> === <span class="hljs-literal">undefined</span><br>    &#125;<br><br>    <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>() ? <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>) : <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> r = <span class="hljs-title class_">MayBe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toUpperCase</span>())<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-literal">null</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-string">&#x27; world&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r) <span class="hljs-comment">// MayBe &#123; _value: null &#125;</span><br></code></pre></td></tr></table></figure><p>面对这种情况还是有解决的方法的</p><h3 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h3><p><code>Either</code> 是两个其中的任何一个，类似于 <code>if...else...</code> 的处理，异常会让函数变得不纯，<code>Either</code> 函数可以用来做异常处理</p><p>来吧，展示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个处理异常的函子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mistake</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mistake</span>(value)<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>  &#125;<br><br>  map (fn) &#123;<br>    <span class="hljs-comment">// 这里同于以往函子的的 map 方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个正常执行的函子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Right</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Right</span>(value)<br>  &#125;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>  &#125;<br><br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Right</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过 formatJSON 方法调用这两个函子</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatJSON</span> (json) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Right</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json))<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Mistake</span>.<span class="hljs-title function_">of</span>(&#123;<span class="hljs-attr">error</span>: e.<span class="hljs-property">message</span>&#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 传递错误参数，捕捉到异常，返回了错误信息</span><br><span class="hljs-comment">// let r = formatJSON(&#x27;&#123;name: zs&#125;&#x27;)</span><br><span class="hljs-comment">// console.log(r) // Mistake &#123; _value: &#123; error: &#x27;Unexpected token n in JSON at position 1&#x27; &#125;&#125;</span><br><br><span class="hljs-comment">// 正常执行</span><br><span class="hljs-keyword">let</span> r = <span class="hljs-title function_">formatJSON</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;zs&quot;&#125;&#x27;</span>)<br><span class="hljs-comment">// console.log(r) // Right &#123; _value: &#123; name: &#x27;zs&#x27; &#125; &#125;</span><br>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>())<br><span class="hljs-comment">// console.log(r) // Right &#123; _value: &#x27;ZS&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="IO-函子"><a href="#IO-函子" class="headerlink" title="IO 函子"></a>IO 函子</h3><p>IO函子中的 <code>_value</code> 是一个函数，这里是把函数作为值来处理。IO函子可以把不纯的动作存储到 <code>_value</code> 中，延迟执行这个不纯的操作(惰性执行)，包装当前的纯操作，把不纯的操作交个带调用者来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IO</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> value)<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = fn<br>  &#125;<br><br>  map (fn) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(fp.<span class="hljs-title function_">flowRight</span>(fn, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-variable constant_">IO</span>.<span class="hljs-title function_">of</span>(process).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">execPath</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r.<span class="hljs-title function_">_value</span>())<br></code></pre></td></tr></table></figure><h3 id="Task-异步任务"><a href="#Task-异步任务" class="headerlink" title="Task 异步任务"></a>Task 异步任务</h3><p>异步任务实现比较复杂，这里使用 <code>floktale</code> 中的 <code>Task</code> 演示，[floktale](<a href="https://www.floktale/">https://www.floktale</a> .com) 是一个标准的函数式编程库，和 <code>lodash、ramda</code>不同的是它没有提供很多功能函数，只提供了一些函数处理操作，例如：<code>compose、curry</code>等，一些函子 &#96;Task、Either、MayBe等</p><p>下面先演示一下 <code>floktale</code> 中的 <code>compose、curry</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; compose, curry &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;folktale/core/lambda&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; toUpper, first &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br><br><span class="hljs-comment">// 第一个参数是要表明回调函数的参数个数，文档上讲是为了避免一些错误</span><br><span class="hljs-keyword">let</span> f = <span class="hljs-title function_">curry</span>(<span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y)<br><br><span class="hljs-comment">// console.log(f(1,2))</span><br><span class="hljs-comment">// console.log(f(1)(3))</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-title function_">compose</span>(toUpper, first)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">c</span>([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>]))<br></code></pre></td></tr></table></figure><ul><li><code>Task</code> 异步执行<ul><li>folktale(2.3.2) 2.x 中的 Task 和 1.0 中的区别还是挺大的，1.0中的用法更接近我们现在演示的函子，这里使用 2.3.2 来演示<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  Task 函子</span><br><span class="hljs-keyword">const</span> &#123; task &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;folktale/concurrency/task&#x27;</span>)<br><span class="hljs-keyword">const</span> fs  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; split, find &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br><br><span class="hljs-comment">// 返回一个 task 函子</span><br><span class="hljs-comment">// const readFile = filename =&gt; task(resolver =&gt; &#123;</span><br><span class="hljs-comment">//   fs.readFile(filename, &#x27;UTF-8&#x27;, (err, data) =&gt; &#123;</span><br><span class="hljs-comment">//     if(err) resolver.reject(err)</span><br><span class="hljs-comment">//     resolver.resolve(data)</span><br><span class="hljs-comment">//   &#125;)</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// 读取 package.json 文件找到version</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span> (filename) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">task</span>(<span class="hljs-function"><span class="hljs-params">resolver</span> =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(err) resolver.<span class="hljs-title function_">reject</span>(err)<br><br>      resolver.<span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 找到文件后并不会读取</span><br><span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;package.json&#x27;</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;version&#x27;</span>)))<br>  <span class="hljs-comment">// 使用 run 方法读取文件</span><br>  .<span class="hljs-title function_">run</span>()<br>  .<span class="hljs-title function_">listen</span>(&#123;<br>    <span class="hljs-attr">onRejected</span>: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err),<br>    <span class="hljs-attr">onResolved</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>  &#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Pointed-函子"><a href="#Pointed-函子" class="headerlink" title="Pointed 函子"></a>Pointed 函子</h3><p><code>Pointed</code> 函子是实现了 of 静态方法的函子，of 方法是为了避免使用 <code>new</code> 来创建对象实例，更深层的含义是 <code>of</code> 方法用来把值直接放到上下文 Context(把值放到容器中，使用 map 来处理值)，这个也是一直在使用的函子 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (value) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> (value) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>(value)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="Monad-单-函子"><a href="#Monad-单-函子" class="headerlink" title="Monad (单)函子"></a>Monad (单)函子</h3><ul><li><code>monad</code> 函子是可以变扁的 <code>Pointed</code> 函子, <code>IO(IO(x))</code></li><li>一个函子如果有 <code>join</code> 和 <code>of</code> 两个方法并遵守一些定律就是一个 Monad</li></ul><p>来吧，最后一个展示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash/fp&#x27;</span>)<br>  <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>  <span class="hljs-comment">// IO Monad</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">IO</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span> = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> value)<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = fn<br>    &#125;<br><br>    map (fn) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(fp.<span class="hljs-title function_">flowRight</span>(fn, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>))<br>    &#125;<br>    <span class="hljs-comment">// 使用 json 方法 把函子变扁拍平，也就是调用一次</span><br>    join () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_value</span>()<br>    &#125;<br><br>    flatMap (fn) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">map</span>(fn).<span class="hljs-title function_">join</span>()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">readFile</span> = filename =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">print</span> = x =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>    <span class="hljs-keyword">return</span> x<br>  &#125;)<br><br>  <span class="hljs-keyword">let</span> r = <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;package.json&#x27;</span>)<br>    .<span class="hljs-title function_">map</span>(fp.<span class="hljs-property">toUpper</span>)<br>    .<span class="hljs-title function_">flatMap</span>(print)<br>    .<span class="hljs-title function_">join</span>()<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.JPG" class="" title="图片引用方法一"><p><img src="/./%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.JPG" alt="图片引用方法二"></p><p><img src="/images/test.JPG" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重学 JavaScript</title>
    <link href="/2021/06/10/Javascript%20notes/"/>
    <url>/2021/06/10/Javascript%20notes/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 是 Web 的编程语言。所有现代的 HTML 页面都使用 JavaScript。<br>曾经有一份绝顶牛批的学习文档摆在我面前，而我却没有珍惜，失去之后才后悔莫及。</p><h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><h4 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h4><h2 id="1-浏览器知识拓展"><a href="#1-浏览器知识拓展" class="headerlink" title="1. 浏览器知识拓展"></a>1. 浏览器知识拓展</h2><h3 id="1-主流浏览器都有哪些？内核分别是什么？"><a href="#1-主流浏览器都有哪些？内核分别是什么？" class="headerlink" title="1. 主流浏览器都有哪些？内核分别是什么？"></a>1. 主流浏览器都有哪些？内核分别是什么？</h3><table><thead><tr><th>主流浏览器</th><th>内核</th></tr></thead><tbody><tr><td>Chrome</td><td>Webkit&#x2F;Blink(2014)</td></tr><tr><td>Firefox</td><td>Gecko</td></tr><tr><td>IE</td><td>Trident</td></tr><tr><td>Safari</td><td>Webkit</td></tr><tr><td>Opera</td><td>Presto</td></tr></tbody></table><hr><h3 id="2-浏览器的组成部分"><a href="#2-浏览器的组成部分" class="headerlink" title="2. 浏览器的组成部分"></a>2. 浏览器的组成部分</h3><ol><li>shell部分(浏览器的外壳，图形界面)</li><li>内核部分<ul><li>渲染引擎（语法规则和渲染）</li><li>Javascript 引擎</li><li>其他模块</li></ul></li></ol><h2 id="2-引入方式"><a href="#2-引入方式" class="headerlink" title="2. 引入方式"></a>2. 引入方式</h2><ol><li>内联脚本</li></ol><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>外链脚本</li></ol><p>基本语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;./js/main.js&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>. 内嵌脚本</li></ol><p>基本语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">function()</span> &#123;<span class="hljs-attr">console.log</span>(&#x27;内嵌脚本&#x27;)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-Web标准"><a href="#4-Web标准" class="headerlink" title="4.Web标准"></a>4.Web标准</h3><p>W3C标准：结构、样式、行为相分离，通常都会采用外链的方式</p><h2 id="3-varible-变量"><a href="#3-varible-变量" class="headerlink" title="3. varible 变量"></a>3. varible 变量</h2><h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h4><h5 id="声明、赋值步骤分解"><a href="#声明、赋值步骤分解" class="headerlink" title="声明、赋值步骤分解"></a>声明、赋值步骤分解</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;     <span class="hljs-comment">// 变量声明</span><br>a = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 变量赋值</span><br></code></pre></td></tr></table></figure><h5 id="单一var模式"><a href="#单一var模式" class="headerlink" title="单一var模式"></a>单一<code>var</code>模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a,<br>    b,<br>    c = <span class="hljs-number">300</span>,<br>    d = <span class="hljs-number">400</span>,<br>    e = <span class="hljs-number">500</span>;<br><br><span class="hljs-comment">// 一个变量同时只能存储一个值</span><br><span class="hljs-comment">// 运算的顺序 = 右面的内容计算完再进行复制</span><br></code></pre></td></tr></table></figure><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ol><li>变量名必须以 <strong>英文字母 、_ 、$</strong>  开头</li><li>变量名可以包括 <strong>英文字母、_ 、$、数字</strong> </li><li>不可以使用系统的 <strong>关键字、保留字</strong> 作为变量名</li></ol><h2 id="4-DataType-数据类型"><a href="#4-DataType-数据类型" class="headerlink" title="4. DataType 数据类型"></a>4. DataType 数据类型</h2><h5 id="原始值-amp-引用值"><a href="#原始值-amp-引用值" class="headerlink" title="原始值&amp;引用值"></a>原始值&amp;引用值</h5><table>  <tr>    <th>数据类型</th>    <th>语法</th>    <th>描述</th>    <th>区别</th>  </tr>  <tr>      <td rowspan="5">原始值</td>    <td>Number</td>    <td>数值类型</td>    <td rowspan="5" style="width: 400px">       <ol>        <li>原始值存储于栈(stack)内存- 先进后出（first in last out）- 不可改变的原始值</li>        <li>原始值与原始值相互赋值是拷贝</li>      </ol>      </ul>      </td>  </tr>  <tr>    <td>String</td>    <td>字符串类型</td>  </tr>  <tr>    <td>Boolean</td>    <td>布尔类型</td>  </tr>  <tr>    <td>undefined</td>    <td>undefined类型</td>  </tr>   <tr>    <td>Null</td>    <td>空指针类型</td>  </tr>  <tr>        <td rowspan="5">引用值</td>    <td>Object</td>    <td>对象类型</td>    <td rowspan="5">      <ol>        <li>引用值大部分存储于堆(heap)内存，栈内存内存储的是引用地址-先进先出</li>        <li>引用值赋值是指定引用</li>      </ol>      </ul>            </td>        </tr></table><h5 id="基本编写规则"><a href="#基本编写规则" class="headerlink" title="基本编写规则"></a>基本编写规则</h5><ol><li>语句后面要用分号结束</li><li>js语法错误会引发后续代码终止，但不会影响其他 js 代码块</li><li>书写格式要规范， “ &#x3D; + &#x2F; - ” 两边都应该有空格</li></ol><hr><h2 id="5-操作符"><a href="#5-操作符" class="headerlink" title="5. 操作符"></a>5. 操作符</h2><h3 id="1-运算操作符"><a href="#1-运算操作符" class="headerlink" title="1. 运算操作符"></a>1. 运算操作符</h3><h5 id="1-1“-”-运算符的两个功能"><a href="#1-1“-”-运算符的两个功能" class="headerlink" title="1.1“+” 运算符的两个功能"></a>1.1“+” 运算符的两个功能</h5><blockquote><p>数学运算，字符串连接，任何数据类型与字符串相加都等于字符串</p></blockquote><h5 id="1-2-“-”，“-”，“-x2F-”，“-”，“-x3D-”，“-”"><a href="#1-2-“-”，“-”，“-x2F-”，“-”，“-x3D-”，“-”" class="headerlink" title="1.2 “ - ”，“ * ”，“ &#x2F; ”，“ % ”，“ &#x3D; ”，“ () ”"></a>1.2 “ - ”，“ * ”，“ &#x2F; ”，“ % ”，“ &#x3D; ”，“ () ”</h5><blockquote><p>与数学运算相同， “ () ” 优先级最高，“ &#x3D; ” 优先级最低</p></blockquote><h5 id="1-3-“-”、“–”、“-x3D-”、“-x3D-”、“-x2F-x3D-”、“-x3D-”、“-x3D-”"><a href="#1-3-“-”、“–”、“-x3D-”、“-x3D-”、“-x2F-x3D-”、“-x3D-”、“-x3D-”" class="headerlink" title="1.3 “++”、“–”、“+&#x3D;”、“-&#x3D;”、“&#x2F;&#x3D;”、“*&#x3D;”、“%&#x3D;”"></a>1.3 “++”、“–”、“+&#x3D;”、“-&#x3D;”、“&#x2F;&#x3D;”、“*&#x3D;”、“%&#x3D;”</h5><h5 id="1-4-注意"><a href="#1-4-注意" class="headerlink" title="1.4. 注意"></a>1.4. 注意</h5><blockquote><p>赋值顺序 自右向左， 计算顺序 自左向右 </p></blockquote><hr><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><h5 id="“-gt-”、“-lt-”、“-x3D-x3D-”、“-gt-x3D-”、“-lt-x3D-”、“-x3D-”"><a href="#“-gt-”、“-lt-”、“-x3D-x3D-”、“-gt-x3D-”、“-lt-x3D-”、“-x3D-”" class="headerlink" title="“&gt;”、“&lt;”、“&#x3D;&#x3D;”、“&gt;&#x3D;”、“&lt;&#x3D;”、“!&#x3D;”"></a>“&gt;”、“&lt;”、“&#x3D;&#x3D;”、“&gt;&#x3D;”、“&lt;&#x3D;”、“!&#x3D;”</h5><blockquote><p>与数学中的定义相同，比较的结果为 boolean 类型的值 true或false，字符串比较的是 ascii 码</p></blockquote><hr><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><h4 id="1-“-amp-amp-”、“-”、“-”-与或非"><a href="#1-“-amp-amp-”、“-”、“-”-与或非" class="headerlink" title="1.“&amp;&amp;”、“||”、“!”: 与或非"></a>1.“&amp;&amp;”、“||”、“!”: 与或非</h4><h5 id="“-amp-amp-”"><a href="#“-amp-amp-”" class="headerlink" title="“&amp;&amp;”"></a>“&amp;&amp;”</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//4</span><br><span class="hljs-comment">// 如果表达式都为true，则返回最后一个表达式的计算结果，如果有false则直接返回当前为false的表达式，后面再有表达式也不再会向后计算</span><br><br><span class="hljs-comment">// 应用-中断作用</span><br>data &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据获取成功！&#x27;</span>);       <span class="hljs-comment">//短路语句</span><br>data &amp;&amp; <span class="hljs-title function_">fn</span>(data);<br></code></pre></td></tr></table></figure><h5 id="“-”"><a href="#“-”" class="headerlink" title="“||”"></a>“||”</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span> || <span class="hljs-literal">false</span> || <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 返回为true的表达式，如果都为false则返回最后一个为false的表达式</span><br><br><span class="hljs-comment">// 应用 + 点击事件判断</span><br>div.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 获取事件源对象(e)中, IE浏览器和非IE浏览器是不同的, 一般用于做浏览器的兼容</span><br>  <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>; <span class="hljs-comment">// window.event IE 浏览器存储事件源对象的关键字</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="“-”-1"><a href="#“-”-1" class="headerlink" title="“!”"></a>“!”</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将表达式转换为布尔值再取反</span><br><span class="hljs-keyword">var</span> a = !<span class="hljs-number">123</span>; <span class="hljs-comment">// false</span><br><span class="hljs-keyword">var</span> b = !<span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// true</span><br><span class="hljs-keyword">var</span> b = !!<span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="2-在系统中被默认为-false-的值"><a href="#2-在系统中被默认为-false-的值" class="headerlink" title="2. 在系统中被默认为 false 的值"></a>2. 在系统中被默认为 false 的值</h4><ol><li>undefined</li><li>null</li><li>NaN</li><li>“” || “ “（空串或者空的串）</li><li>0</li></ol><h2 id="6-条件语句"><a href="#6-条件语句" class="headerlink" title="6. 条件语句"></a>6. 条件语句</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a>1. <code>if</code></h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(条件) &#123; <span class="hljs-comment">// 如何条件为 true 则执行代码体1</span><br>  <span class="hljs-comment">// 代码体1</span><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如何条件为 false 则执行代码体2</span><br>  <span class="hljs-comment">// 代码体2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-if-else"><a href="#2-if-else" class="headerlink" title="2. if else"></a>2. <code>if else</code></h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-comment">// 代码体1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-comment">// 代码体2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 代码体3</span><br>&#125;<br><span class="hljs-comment">// 使用 if else 做条件互斥，满足某一个条件则不会再往下进行判断</span><br></code></pre></td></tr></table></figure><h3 id="3-for"><a href="#3-for" class="headerlink" title="3. for"></a>3. <code>for</code></h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">for循环的执行顺序拆解</span><br><span class="hljs-comment">1. var i= 0;</span><br><span class="hljs-comment">  2. if(i &lt; 10) &#123;</span><br><span class="hljs-comment">console.log(&quot;a&quot;);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  3. i++;</span><br><span class="hljs-comment">  4. if(i &lt; 10) &#123;</span><br><span class="hljs-comment">  console.log(&quot;a&quot;);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// for循环拆解写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(; a &lt; <span class="hljs-number">10</span>;) &#123; <span class="hljs-comment">// 空缺的位置直接忽略</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  i ++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-while"><a href="#4-while" class="headerlink" title="4. while"></a>4. <code>while</code></h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 满足条件就执行</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(i);<br>  i ++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-do-while"><a href="#5-do-while" class="headerlink" title="5. do-while"></a>5. <code>do-while</code></h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(i);<br>  i ++;<br>&#125;<span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="6-switch-case"><a href="#6-switch-case" class="headerlink" title="6. switch case"></a>6. <code>switch case</code></h3><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span>(number) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 需要配合break; 来终止语句停止后面的判断和输出</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;default&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-break-continue"><a href="#7-break-continue" class="headerlink" title="7. break continue"></a>7. <code>break</code> <code>continue</code></h3><ul><li><code>break</code>: 结束当前判断 &#x2F; 循环</li><li><code>continue</code>: 跳过本次判断 &#x2F; 循环</li></ul><hr><h2 id="编码练习"><a href="#编码练习" class="headerlink" title="编码练习"></a>编码练习</h2><h3 id="1-计算-2-的-n-次幂，-n-可输入，-n-为自然数"><a href="#1-计算-2-的-n-次幂，-n-可输入，-n-为自然数" class="headerlink" title="1. 计算 2 的 n 次幂， n 可输入， n 为自然数"></a>1. 计算 2 的 n 次幂， n 可输入， n 为自然数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*  规律</span><br><span class="hljs-comment">    1 * 2</span><br><span class="hljs-comment">    1 * 2 * 2</span><br><span class="hljs-comment">    1 * 2 * 2 * 2</span><br><span class="hljs-comment">    1 * 2 * 2 * 2 * 2</span><br><span class="hljs-comment">  */</span> <br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;input&#x27;</span>));<br><span class="hljs-keyword">var</span> mul = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>  mul *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(mul);<br></code></pre></td></tr></table></figure><h3 id="2-计算-n-的阶乘，-n-可输入"><a href="#2-计算-n-的阶乘，-n-可输入" class="headerlink" title="2. 计算 n 的阶乘， n 可输入"></a>2. 计算 n 的阶乘， n 可输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 规律</span><br><span class="hljs-comment">5！：5 * 4 * 3 * 2 * 1 * 1</span><br><span class="hljs-comment">  4！：4 * 3 * 2 * 1 * 1</span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;计算n的阶乘&#x27;</span>));<br><span class="hljs-keyword">var</span> mul = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  mul *= i;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mul);<br></code></pre></td></tr></table></figure><h3 id="3-斐波那契数列第n位，n-可输入"><a href="#3-斐波那契数列第n位，n-可输入" class="headerlink" title="3. 斐波那契数列第n位，n 可输入"></a>3. 斐波那契数列第n位，n 可输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 规律</span><br><span class="hljs-comment">    1 1 2 5 8</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 实现</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;斐波那契&quot;</span>))<br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> num3 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i ++) &#123;<br>    num3 = num1 + num2;<br>    num1 = num2;<br>    num2 = num3;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num3);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-编写一个程序，输入三位数-然后将其反向输出"><a href="#4-编写一个程序，输入三位数-然后将其反向输出" class="headerlink" title="4. 编写一个程序，输入三位数, 然后将其反向输出"></a>4. 编写一个程序，输入三位数, 然后将其反向输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;三位数&quot;</span>));<br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> num1 = num % <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> num2 = (num - num1 % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> num3 = (num - (num2 * <span class="hljs-number">10</span> + num1) )/ <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, num2, num3);<br>sum = (num1 * <span class="hljs-number">100</span>) + (num2 * <span class="hljs-number">10</span> ) + num3;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br></code></pre></td></tr></table></figure><h3 id="5-输入三个数字，打印最大的"><a href="#5-输入三个数字，打印最大的" class="headerlink" title="5. 输入三个数字，打印最大的"></a>5. 输入三个数字，打印最大的</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numA = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;数字A&quot;</span>));<br><span class="hljs-keyword">var</span> numB = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;数字B&quot;</span>));<br><span class="hljs-keyword">var</span> numC = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;数字C&quot;</span>));<br><span class="hljs-keyword">if</span>(numA &gt; numB) &#123;<br>  <span class="hljs-keyword">if</span>(numA &gt; numC) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numA);<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numC);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span>(numB &gt; numC) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numB);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numC);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-打印100以内的质数"><a href="#6-打印100以内的质数" class="headerlink" title="6. 打印100以内的质数"></a>6. 打印100以内的质数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i ++) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++) &#123;<br>    <span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>) &#123;<br>      count ++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(count == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;<br>  count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-typeof-六种数据类型"><a href="#7-typeof-六种数据类型" class="headerlink" title="7. typeof 六种数据类型"></a>7. typeof 六种数据类型</h2><ol><li>number</li><li>string</li><li>boolean</li><li>object : 数组、对象和null都会返回object (null 最初是对象占位符,代替空对象,属于历史遗留问题) </li><li>undefined： 变量声明却没有初始化时，undefined会作为变量的默认值。</li><li>functtion</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>typeof() 在ES5及以下版本中访问没有定义的变量是不会报错的 </p></blockquote><hr><h2 id="8-类型转换"><a href="#8-类型转换" class="headerlink" title="8. 类型转换"></a>8. 类型转换</h2><h3 id="1-显式类型转换"><a href="#1-显式类型转换" class="headerlink" title="1. 显式类型转换"></a>1. 显式类型转换</h3><h4 id="Number-param"><a href="#Number-param" class="headerlink" title="Number(param)"></a><code>Number(param)</code></h4><blockquote><p>将参数转换为数值类型并返回。</p></blockquote><hr><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul><li><code>null</code>    : 0</li><li><code>undefined</code>: NaN (NaN: Not a Number(不是一个数))</li><li><code>123abc</code>  : NaN</li><li><code>true</code>    : 1</li></ul><hr><h4 id="parseInt-param"><a href="#parseInt-param" class="headerlink" title="parseInt(param)"></a><code>parseInt(param)</code></h4><blockquote><p>将参数转换为整数 intiger</p></blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><ul><li><code>true</code>  : NaN</li><li><code>1.9</code>   : 1</li><li><code>123abc</code>: 123 (如果以数字位开头则会自动截断后面的非数字位，将数字位返回)</li><li><code>100px</code> : 100</li><li><code>parseInt(param, radix)</code>: radix: 表示基底，例如：parseInt(num, 16); 以十六进制将num转换为十进制</li></ul><ul><li><code>parseInt(30, 16)</code>: 1e</li></ul><hr><h4 id="parseFloat-param"><a href="#parseFloat-param" class="headerlink" title="parseFloat(param)"></a><code>parseFloat(param)</code></h4><blockquote><p> 将参数转换为浮点型</p></blockquote><hr><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><ul><li>100           : 100</li><li>100.1        : 100.1</li><li>100.1.1     : 100.1</li><li>100.1abc   : 100.1</li></ul><hr><h4 id="String-param"><a href="#String-param" class="headerlink" title="String(param)"></a><code>String(param)</code></h4><blockquote><p>将参数转换为字符串</p></blockquote><hr><h4 id="Boolean-param"><a href="#Boolean-param" class="headerlink" title="Boolean(param)"></a><code>Boolean(param)</code></h4><blockquote><p> 将参数转换为布尔类型，可以参考上面章节中<strong>逻辑运算符&gt;在系统中被认为 false 的值</strong></p></blockquote><hr><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a><code>toString()</code></h4><blockquote><p>是用 “.” 的方式调用当前方法,将调用此方法的属性转换为字符串</p></blockquote><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><ul><li><code>sex.toString()</code>: “18” (不要问，问就是永远18岁)</li><li>不可以调用<code>toString()</code>方法的类型<ol><li>undefined</li><li>null</li></ol></li></ul><p><code>.toString(radix)</code>: 将十进制的值转换为目标进制(radix)</p><hr><h3 id="2-隐式类型转换"><a href="#2-隐式类型转换" class="headerlink" title="2. 隐式类型转换"></a>2. 隐式类型转换</h3><h4 id="isNaN-param"><a href="#isNaN-param" class="headerlink" title="isNaN(param)"></a><code>isNaN(param)</code></h4><blockquote><p> 判断是不是一个数</p></blockquote><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) -隐式调用-&gt; <span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) =然后和<span class="hljs-title class_">NaN</span>进行比较= <span class="hljs-title class_">NaN</span>?  <span class="hljs-attr">true</span>:<span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="、-、-、-一元正负"><a href="#、-、-、-一元正负" class="headerlink" title="++、--、+、- (一元正负)"></a><code>++、--、+、- (一元正负)</code></h4><blockquote><p>自动隐式调用Number(),强制转换成Number类型</p></blockquote><h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自动隐式调用Number(),强制转换成Number类型</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;123&quot;</span>;<br>a++;<br><span class="hljs-comment">// a = 124</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;abc&quot;</span>;<br>b++;<br><span class="hljs-comment">// b = NaN</span><br></code></pre></td></tr></table></figure><hr><h4 id="、-、-、"><a href="#、-、-、" class="headerlink" title="+ -、*、/、%"></a><code>+ -、*、/、%</code></h4><blockquote><ol><li>当加号两边有一个是字符串的，则将两边都转换为字符串并连接，如果是数值就做加法运算</li><li>如果是数值类型会隐式调用Number()方法</li></ol></blockquote><hr><h4 id="amp-amp-、-、！"><a href="#amp-amp-、-、！" class="headerlink" title="&amp;&amp;、||、！"></a><code>&amp;&amp;、||、！</code></h4><blockquote><p>“!” 调用 Boolean() 进行转换</p></blockquote><hr><h4 id="gt-、-lt-、-lt-、-gt"><a href="#gt-、-lt-、-lt-、-gt" class="headerlink" title="&gt;、&lt;、&lt;=、&gt;="></a><code>&gt;、&lt;、&lt;=、&gt;=</code></h4><ul><li><code>var a = &quot;3&quot; &gt; 2</code>  : ture; 有数字时会隐式调用 Number() 进行转换再比较</li><li><code>var a = &quot;b&quot; &gt; &quot;c&quot;</code>: false 如果比较运算符两侧都是字符串，则比较的是对应的ascii码</li></ul><hr><h4 id="、"><a href="#、" class="headerlink" title="==、!="></a><code>==、!=</code></h4><blockquote><p>同样有隐式类型转换</p></blockquote><p>[^提示]: NaN 与任何值相比较都不相等包括自身，<code>undefined == null - true </code></p><hr><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><h3 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1. 定义方式"></a>1. 定义方式</h3><hr><h4 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1. 函数声明"></a>1. 函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2. 函数表达式"></a>2. 函数表达式</h4><hr><h5 id="1-命名函数表达式"><a href="#1-命名函数表达式" class="headerlink" title="1. 命名函数表达式"></a>1. 命名函数表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// test 不代表函数体，在函数中 fn.name == test</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">name</span>); <span class="hljs-comment">// test</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-匿名函数表达式（常用方式）"><a href="#2-匿名函数表达式（常用方式）" class="headerlink" title="2. 匿名函数表达式（常用方式）"></a>2. 匿名函数表达式（常用方式）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-组成形式"><a href="#2-组成形式" class="headerlink" title="2. 组成形式"></a>2. 组成形式</h3><ol><li><p>函数名称</p><ol><li>命名规则与变量一致</li><li>多个单词使用小驼峰命名法 <code>theIsFnName</code></li></ol></li><li><p>参数</p><ol><li><p>形参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递形式参数（形参）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-comment">// 在括号中传递a, b就相当于隐式的在函数中  var a; var b;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递实际参数（实参）</span><br><span class="hljs-title function_">functionName</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>arguments</code></p><p>一个类数组，保存传进的实参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">a, b, c, d</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);   <span class="hljs-comment">// 打印实参列表 Arguments(3) [1, 2, 4]</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(functionName.<span class="hljs-property">length</span>);  <span class="hljs-comment">//  5 计算形参的长度</span><br>    <span class="hljs-comment">// 如果形参比实参多，那么多余的形参将默认是undefined，未赋值</span><br>&#125;<br><span class="hljs-title function_">functionName</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>[^注]: 形参和实参存在相互映射关系，但又相互独立，如果形参 &gt; 实参，则多余的形参不存在映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不再存在映射关系案例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// undefined</span><br>  <span class="hljs-comment">// 或者</span><br>  b = <span class="hljs-number">2</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// undefined</span><br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>return</code></p><p>终止当前函数，<code>return</code>之后的语句将不会得到执行</p><p>可以在该关键字之后设置返回值</p></li></ol><hr><h2 id="10-递归"><a href="#10-递归" class="headerlink" title="10. 递归"></a>10. 递归</h2><blockquote><p>类似于循环，使一个处理函数根据需求执行多次</p><p>关键点</p><ol><li>找规律</li><li>找出口</li></ol></blockquote><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 找规律    </span><br> <span class="hljs-comment">// 2. 找出口</span><br> <br> <span class="hljs-comment">// 使用递归实现阶乘</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">n</span>) &#123;<br>     <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 用已知的作为递归的出口</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">mul</span>(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 使用公式作为递归的逻辑</span><br> &#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mul</span>(<span class="hljs-number">5</span>))<br> <br> <span class="hljs-comment">// 使用递归实现斐波那契数列 </span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fb</span>(<span class="hljs-params">n</span>) &#123;<br>     <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 用已知的作为递归的出口</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">1</span>) + <span class="hljs-title function_">fb</span>(n-<span class="hljs-number">2</span>); <span class="hljs-comment">// 使用公式作为递归的逻辑</span><br> &#125;<br> <span class="hljs-title function_">fb</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="11-Javascript-执行三部曲"><a href="#11-Javascript-执行三部曲" class="headerlink" title="11. Javascript 执行三部曲"></a>11. Javascript 执行三部曲</h2><h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. 语法分析</h3><blockquote><p>通篇扫描是否存在语法错误</p></blockquote><hr><h3 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h3><blockquote><p>预编译发生在函数执行的前一刻，有句话描述说：“函数声明整体提升，变量声明提升”，会将声明的函数和变量的声明，提升到当前逻辑的最顶端</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined，</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//因为变量声明已经提升到了逻辑的最前面，所以访问时输出 undefined 未赋值，而并不是 not defined</span><br></code></pre></td></tr></table></figure><p>但是上面那句话的使用场景有限，不够严谨，在相对复杂的情况下不够用。</p><h5 id="预编译前奏"><a href="#预编译前奏" class="headerlink" title="预编译前奏"></a>预编译前奏</h5><p><code>imply global</code> 暗示全局变量: 即任何变量在未经声明就赋值，此变量就为全局对象window所有。严格情况下这种不能称为变量，因为真正的变量是不可以通过<code>delete</code>关键字删除的，而这种可以，它是作为 window 的属性存在的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a =  <span class="hljs-number">123</span>;   <span class="hljs-comment">// a 为全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ao</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> a = b = <span class="hljs-number">123</span>;   <span class="hljs-comment">// b 为暗示全局变量 </span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>); <br></code></pre></td></tr></table></figure><p>一切声明的全局变量，全是window的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a  = <span class="hljs-number">123</span>;   <span class="hljs-comment">// === window.a = 123;</span><br>b = <span class="hljs-number">234</span>;    <span class="hljs-comment">// === window.b = 234;</span><br><span class="hljs-comment">// window 就是全局的域</span><br></code></pre></td></tr></table></figure><h5 id="预编译四部曲"><a href="#预编译四部曲" class="headerlink" title="预编译四部曲"></a>预编译四部曲</h5><p>预编译发生在执行的前一刻。</p><ol><li>创建AO对象（Activation Object：执行期上下文，全局对象会创建一个GO对象，GO &#x3D;&#x3D;&#x3D; window）</li><li>将形参和实参作为AO对象的属性名，并赋值 undefined ，如果在全局中则忽略此步骤。</li><li>将实参和形参的值相统一。</li><li>将函数声明作为 AO 对象的属性名，并将函数体作为该属性名的属性值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">// fn() &#123;&#125;</span><br>      <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">// 123</span><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">// 123</span><br>      <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);    <span class="hljs-comment">// fn() &#123;&#125;</span><br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">d</span>(<span class="hljs-params"></span>) &#123;&#125;；<br>  &#125;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.创建AO对象</span><br><span class="hljs-comment">      AO&#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2.将形参和变量声明作为AO对象的属性，并赋值 undefined</span><br><span class="hljs-comment">    AO&#123;</span><br><span class="hljs-comment">    a : undefined   形参和变量相同时后者覆盖</span><br><span class="hljs-comment">    b : undefined</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    3.将实参和形参相统一</span><br><span class="hljs-comment">    AO&#123;</span><br><span class="hljs-comment">    a : 1,</span><br><span class="hljs-comment">    b : undefined</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    4.将函数声明作为AO对象的属性，并赋值函数体</span><br><span class="hljs-comment">    AO&#123;</span><br><span class="hljs-comment">    a : fn()&#123;&#125;</span><br><span class="hljs-comment">    b : undefined</span><br><span class="hljs-comment">    d : fn()&#123;&#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// undefined</span><br>    <span class="hljs-keyword">if</span>(a) &#123;   <span class="hljs-comment">// 预编译时会直接提取 if 中的变量声明</span><br>      <span class="hljs-keyword">var</span> b = <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b; <span class="hljs-comment">// undefined</span><br>    c = <span class="hljs-number">234</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// 234</span><br>  &#125;<br>  <span class="hljs-keyword">var</span> a;<br>  <span class="hljs-title function_">test</span>();<br>  a = <span class="hljs-number">10</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br></code></pre></td></tr></table></figure><h3 id="3-解释执行"><a href="#3-解释执行" class="headerlink" title="3. 解释执行"></a>3. 解释执行</h3><hr><h2 id="12-作用域"><a href="#12-作用域" class="headerlink" title="12 作用域"></a>12 作用域</h2><h4 id="1-作用域初探"><a href="#1-作用域初探" class="headerlink" title="1. 作用域初探"></a>1. 作用域初探</h4><blockquote><p>作用域的定义：变量（变量作用域又称上下文）和函数生效（能被访问）的区域</p></blockquote><h5 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 全局变量</span><br></code></pre></td></tr></table></figure><h5 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 局部变量</span><br>&#125;    <br></code></pre></td></tr></table></figure><h5 id="3-访问顺序"><a href="#3-访问顺序" class="headerlink" title="3. 访问顺序"></a>3. 访问顺序</h5><p>内部可以访问外部变量，外部不可以访问内部变量，自内向外</p><hr><h4 id="2-作用域精解"><a href="#2-作用域精解" class="headerlink" title="2. 作用域精解"></a>2. 作用域精解</h4><h5 id="1-执行期上下文"><a href="#1-执行期上下文" class="headerlink" title="1. 执行期上下文"></a>1. 执行期上下文</h5><blockquote><p>当函数执行时，会创建一个称为 <strong>执行期上下文</strong> 的内部对象(AO)。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行期上下文被销毁</p></blockquote><h5 id="2-查找变量"><a href="#2-查找变量" class="headerlink" title="2. 查找变量"></a>2. 查找变量</h5><blockquote><p>从作用域的顶端依次向下查找</p></blockquote><h5 id="3-scope"><a href="#3-scope" class="headerlink" title="3. [[scope]]"></a>3. <code>[[scope]]</code></h5><blockquote><p>每个javascript函数都是一个对象，对象中有些属性是我们可以访问（例如: <code>functionName.name</code>），但有些不可以，这些属性<strong>仅供javascript引擎存取</strong>，[[scope ]] 就是其中一个。</p><p>[[ scope ]] 指的就是我们所说的<strong>作用域</strong>，其中存储了执行期上下文的<strong>集合</strong>。</p></blockquote><h5 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4. 作用域链"></a>4. 作用域链</h5><blockquote><p>[[ scope ]] 中所存储的执行期上下文对象的集合，这个集合呈<strong>链式链接</strong>，我们把这种链式链接叫做作<strong>用域链</strong></p></blockquote><p>代码示例1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 每个函数被创建时，会根据当前的执行环境生成作用域链，保存在当前函数的 [[ scope ]] 属性作用域链中</span><br><span class="hljs-comment">// 当函数被执行时，会生成自己的作用域放在[[ scope ]]属性作用域链的最顶端</span><br>  <br><span class="hljs-comment">// 第一步. a函数被定义  生成:[[ scope ]]  存储内容: 0 : GO(Global Object)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.</span><br><span class="hljs-comment">    事件：a 函数被定义</span><br><span class="hljs-comment">  生成当前执行期上下文[[scope]]</span><br><span class="hljs-comment">    存储的执行期上下文内容</span><br><span class="hljs-comment">      0 : Global Object</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;       <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  3.</span><br><span class="hljs-comment">  事件：b 函数的定义</span><br><span class="hljs-comment">  生成自己的执行期上下文 [[scope]]</span><br><span class="hljs-comment">  存储的执行期上下文内容</span><br><span class="hljs-comment">  0 : AO(a 函数)</span><br><span class="hljs-comment">  1 : GO</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;      <br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">234</span>;<br>  &#125;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    4.</span><br><span class="hljs-comment">    事件：b 函数被执行</span><br><span class="hljs-comment">    生成自己的执行期上下文存放进 [[scope]]</span><br><span class="hljs-comment">    存储的执行期上下文的内容</span><br><span class="hljs-comment">    0 : AO(b 函数)</span><br><span class="hljs-comment">    1 : AO(a 函数)</span><br><span class="hljs-comment">    2 : GO</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-title function_">b</span>();<br>&#125;<br><span class="hljs-keyword">var</span> glob = <span class="hljs-number">100</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  2.</span><br><span class="hljs-comment">  事件：a函数被执行</span><br><span class="hljs-comment">  将自己的执行期上下文添加到 [[scope]]</span><br><span class="hljs-comment">  存储的执行器上下文内容</span><br><span class="hljs-comment">    0 : AO(a函数)</span><br><span class="hljs-comment">    1 : GO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">a</span>();     <br></code></pre></td></tr></table></figure><p>代码实例2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<br>              <br>          &#125;<br>          <span class="hljs-title function_">c</span>();<br>      &#125;<br>        <span class="hljs-title function_">b</span>();<br>  &#125;<br>  <span class="hljs-title function_">a</span>();<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    a defined a.[[scope]] --&gt; 0:GO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    a doing   a.[[scope]] --&gt; 0:AOa</span><br><span class="hljs-comment">                              1:GO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    b defined b.[[scope]] --&gt; 0:AOa</span><br><span class="hljs-comment">                              1:GO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  b doing   b.[[scope]] --&gt; 0:AOb</span><br><span class="hljs-comment">                              1:AOa</span><br><span class="hljs-comment">                              2:GO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  c defined c.[[scope]] --&gt; 0:AOb</span><br><span class="hljs-comment">                              1:AOa</span><br><span class="hljs-comment">                              2:GO</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c doing   c.[[scope]] --&gt; 0:AOc</span><br><span class="hljs-comment">                              1:AOb</span><br><span class="hljs-comment">                              2:AOa</span><br><span class="hljs-comment">                              3:GO</span><br><span class="hljs-comment">                              </span><br><span class="hljs-comment">所有的 GO、AOa、AOb、AOc 都是同一个执行上下文</span><br><span class="hljs-comment">当一个函数执行完毕时，相对应的执行上下文也会跟着销毁</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure><hr><h2 id="13-闭包"><a href="#13-闭包" class="headerlink" title="13. 闭包"></a>13. 闭包</h2><blockquote><p>当内部函数被保存到外部时，将生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="1-实现公有变量"><a href="#1-实现公有变量" class="headerlink" title="1. 实现公有变量"></a>1. 实现公有变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>        count ++;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> demo;<br>&#125;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">counter</span>();<br><span class="hljs-title function_">counter</span>();<br><span class="hljs-title function_">counter</span>();<br></code></pre></td></tr></table></figure><h5 id="2-做缓存"><a href="#2-做缓存" class="headerlink" title="2. 做缓存"></a>2. 做缓存</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> num = <span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>          num ++;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>      &#125;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>          num --;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>      &#125;<br>      <span class="hljs-keyword">return</span> [a, b];<br>  &#125;<br>  <span class="hljs-keyword">var</span> myArr = <span class="hljs-title function_">test</span>();<br>  myArr[<span class="hljs-number">0</span>]();<br>  myArr[<span class="hljs-number">1</span>]();<br><br><span class="hljs-comment">// -----------------------------------------------------------------------------</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">eater</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> food = <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">var</span> obj = &#123;<br>          eat : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;i am eating&quot;</span> + food);<br>          &#125;,<br>          push : <span class="hljs-keyword">function</span>(<span class="hljs-params">myFood</span>) &#123;<br>              food = myFood;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  obj.<span class="hljs-title function_">eat</span>();<br></code></pre></td></tr></table></figure><h5 id="3-实现封装，私有化属性。"><a href="#3-实现封装，私有化属性。" class="headerlink" title="3.  实现封装，私有化属性。"></a>3.  实现封装，私有化属性。</h5><h5 id="4-模块化开发，防止污染全局变量。"><a href="#4-模块化开发，防止污染全局变量。" class="headerlink" title="4. 模块化开发，防止污染全局变量。"></a>4. 模块化开发，防止污染全局变量。</h5><hr><h2 id="14-立即执行函数"><a href="#14-立即执行函数" class="headerlink" title="14. 立即执行函数"></a>14. 立即执行函数</h2><blockquote><p>此类函数没有声明，在一次执行过后释放。适合初始化工作</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 立即执行函数执执行完之后立即销毁，除此之外和普通函数没有任何不同</span><br><span class="hljs-comment">// 针对初始化功能的函数</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) &#123;<br><br>    <span class="hljs-keyword">return</span> a + b + c;<br><br>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// 可以使用变量接收返回值</span><br><span class="hljs-keyword">var</span> num = (<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) &#123;<br><br>    <span class="hljs-keyword">return</span> a + b + c;<br><br>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h5 id="执行符"><a href="#执行符" class="headerlink" title="执行符()"></a>执行符<code>()</code></h5><p>只有表达式才可以被执行符号执行。</p><h5 id="立即执行函数扩展"><a href="#立即执行函数扩展" class="headerlink" title="立即执行函数扩展"></a>立即执行函数扩展</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 立即函数不同写法</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;());  <span class="hljs-comment">// W3C推荐</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;)(); <br><br><span class="hljs-comment">// 只有表达式才可以被执行符号执行</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;();  <span class="hljs-comment">// 语法错误，此种方式不可以被执行，这种叫做函数声明</span><br><br><span class="hljs-comment">// 能被执行符号执行的函数，这个函数的名字就会被自动忽略</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// a 不再代表函数了</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;();  <span class="hljs-comment">// 可以，函数表达式</span><br><br><span class="hljs-comment">// ()、+(正)、-(负)、!、&amp;&amp;、|| 都可以将一个函数转换为表达式</span><br>- <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;(); <span class="hljs-comment">// 可以正确执行</span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// !!! 注意</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b, c</span>) &#123;  <span class="hljs-comment">// 在这中情况下，系统不会报错，但也不会执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c)<br>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// 系统会自动识别成这样</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br>&#125;<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 不识别成执行符号，看做一个独立的**逗号表达式(知识点再后续文档中呈现)**</span><br></code></pre></td></tr></table></figure><hr><h2 id="15-闭包续"><a href="#15-闭包续" class="headerlink" title="15. 闭包续"></a>15. 闭包续</h2><h3 id="1-闭包的防范"><a href="#1-闭包的防范" class="headerlink" title="1. 闭包的防范"></a>1. 闭包的防范</h3><blockquote><p>闭包会导致多个执行函数共用一个公有变量，如果不是特殊需求，尽量防止这种情况发生。</p></blockquote><h3 id="2-经典案例"><a href="#2-经典案例" class="headerlink" title="2. 经典案例"></a>2. 经典案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给数组的每一位绑定一个函数，并打印出当前下标</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++) &#123;<br>        arr[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">// 赋值函数</span><br>            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">// 返回到外部，形成了闭包</span><br>&#125;<br><span class="hljs-keyword">var</span> myArr = <span class="hljs-title function_">test</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j ++) &#123;<br>    myArr[j]();<br>&#125;<br><span class="hljs-comment">// 执行结果 10 10 10 10 10 10 10 10 10 10 </span><br><span class="hljs-comment">// 形成了闭包，由于在执行数组中的函数时，test 已经执行完毕。 i = 10并不再循环，这是for的判断条件</span><br><span class="hljs-comment">// 形成闭包执行，这10个函数访问的 i 在 test的AO里都已经变成了10</span><br><br><span class="hljs-comment">// 解决方法</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">var</span> arr = [];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++) &#123;<br>     (<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;    <span class="hljs-comment">// 使用立即执行函数，将每次的i用参数的进行进行套现，利用闭包解决闭包</span><br>       arr[n] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(n + <span class="hljs-string">&quot; &quot;</span>)<br>       &#125;<br>     &#125;(i))<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr;<br> &#125;<br> <span class="hljs-keyword">var</span> myArr = <span class="hljs-title function_">test</span>();<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j ++) &#123;<br>     myArr[j](); <span class="hljs-comment">// 执行每个方法</span><br> &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="16-逗号操作符"><a href="#16-逗号操作符" class="headerlink" title="16. 逗号操作符"></a>16. 逗号操作符</h2><blockquote><p>逐个审查每一位元素。如果某位元素需要计算，则计算该元素。最后，返回最后一个元素的计算结果。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 逐个审查每一位元素。如果某位元素需要计算，则计算该元素。最后，返回最后一个元素的计算结果</span><br><span class="hljs-keyword">var</span> a = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> f = (<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br>&#125;,<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>)();<br><span class="hljs-title function_">typeof</span>(f);<br></code></pre></td></tr></table></figure><hr><h2 id="17-对象"><a href="#17-对象" class="headerlink" title="17. 对象"></a>17. 对象</h2><blockquote><p>Object是一种基础的变量类型，属于引用值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mrZhang = &#123;<br> name : <span class="hljs-string">&#x27;zs&#x27;</span>,<br> age : <span class="hljs-number">22</span>,<br> sex : <span class="hljs-string">&#x27;male&#x27;</span>,<br> health : <span class="hljs-number">100</span>,<br> smoke : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I am somkeing&#x27;</span>);<br>   mrZhang.<span class="hljs-property">health</span> --; <span class="hljs-comment">// this.health  this表示当前，第一人称</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-属性的增删改查"><a href="#1-属性的增删改查" class="headerlink" title="1. 属性的增删改查"></a>1. 属性的增删改查</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mrZhang.<span class="hljs-property">wife</span> = <span class="hljs-string">&#x27;xiaoliu&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> mrZhang.<span class="hljs-property">wife</span><br></code></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mrZhang.<span class="hljs-property">sex</span> = <span class="hljs-string">&#x27;female&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mrZhang.<span class="hljs-property">name</span>  <span class="hljs-comment">// 如果对象没有name属性的话会返回undefined（变量没有声明的话会报错）</span><br></code></pre></td></tr></table></figure><h3 id="2-对象的创建方法"><a href="#2-对象的创建方法" class="headerlink" title="2. 对象的创建方法"></a>2. 对象的创建方法</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;    <span class="hljs-comment">// plainObject 对象字面量/对象直接量</span><br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="1-系统自带"><a href="#1-系统自带" class="headerlink" title="1. 系统自带"></a>1. 系统自带</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 得出相同，且相互独立的对象</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Array();</span><br><span class="hljs-comment">  Number();</span><br><span class="hljs-comment">  Boolean();</span><br><span class="hljs-comment">  String();</span><br><span class="hljs-comment">  Date();</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="2-自定义案例"><a href="#2-自定义案例" class="headerlink" title="2. 自定义案例"></a>2. 自定义案例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">color</span>) &#123; <span class="hljs-comment">// 为区分自定义函数和普通函数，使用大驼峰命名法</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color; <span class="hljs-comment">// 使用参数实现自定义</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;BMW&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;1400&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lang</span> = <span class="hljs-string">&#x27;4900&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span> = <span class="hljs-string">&#x27;1000&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> = <span class="hljs-number">100</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">run</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> --;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br><span class="hljs-keyword">var</span> car2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;green&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-构造函数解析"><a href="#3-构造函数解析" class="headerlink" title="3. 构造函数解析"></a>3. 构造函数解析</h3><h4 id="1-内部原理"><a href="#1-内部原理" class="headerlink" title="1. 内部原理"></a>1. 内部原理</h4><ol><li>在函数体最顶端隐式的创建一个 <code>this=&#123;&#125;</code></li><li>执行 <code>this.xxx = xxx</code></li><li>隐式的 <code>return this</code><ul><li>可以手动显式的返回，<code>return(&#123;&#125;, [])</code>只可以返回类型为<code>object</code>的值，原始值无效，自动忽略，有 <code>new</code>不可能返回原始值。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// new 之后函数的变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. var this = &#123;&#125;, AO&#123; this:&#123;name:&#x27;zhagnsan&#x27;&#125; &#125;  // 隐式创建一个this对象</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-comment">/* 2. */</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = <span class="hljs-number">2017</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    3. return this;  隐式 return this;</span><br><span class="hljs-comment">  */</span><br>&#125;<br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  1. 在函数体最前面隐式的创建 this = &#123;&#125;;</span><br><span class="hljs-comment">  2. 执行 this = xxx;</span><br><span class="hljs-comment">  3. 隐式的 return this;</span><br><span class="hljs-comment">    3.1. 可以手动显式 return (&#123;&#125;, [], /..)类型为obj的值，原始值是无效，自动忽略的</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="2-模拟构造函数"><a href="#2-模拟构造函数" class="headerlink" title="2. 模拟构造函数"></a>2. 模拟构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟构造函数(只是简单模拟，并不推荐使用。因为还有更深层次的东西模拟不了)</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, height</span>) &#123;<br>      <span class="hljs-keyword">var</span> that = &#123;&#125;; <span class="hljs-comment">// 模拟构造函数中的 this</span><br>      that.<span class="hljs-property">name</span> = name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;<br>      <span class="hljs-keyword">return</span> that; <br>  &#125;<br>  <span class="hljs-keyword">var</span> person1 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;xiaowang&#x27;</span>, <span class="hljs-number">180</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="18-包装类"><a href="#18-包装类" class="headerlink" title="18. 包装类"></a>18. 包装类</h2><blockquote><p>原始值是坚决不能用属性和方法的，但是通过包装类可以给原始值设置属性即方法</p></blockquote><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h4 id="1-理解原始值和对象"><a href="#1-理解原始值和对象" class="headerlink" title="1. 理解原始值和对象"></a>1. 理解原始值和对象</h4><p>原始值Nubmer和对象Number</p><ol><li><code>var num = 123</code>; &#x2F;&#x2F; 不可以拥有属性和方法</li><li><code>var num = new Number(123)</code>; &#x2F;&#x2F; 数字对象，可以拥有属性和方法</li></ol><p>原始值 String 和 对象String</p><ol><li><code>var str = &#39;abc&#39;</code> &#x2F;&#x2F; 原始值字符串</li><li><code>var str = new String(&#39;abc&#39;)</code>; &#x2F;&#x2F; 字符串对象</li></ol><p>原值值 Boolean 和 对象Boolean</p><ol><li><code>var bool = false</code>; &#x2F;&#x2F; 原始值布尔</li><li><code>var bool = true</code>; &#x2F;&#x2F; 布尔对象</li></ol><h4 id="2-原始值可以设置属性和方法的原理"><a href="#2-原始值可以设置属性和方法的原理" class="headerlink" title="2. 原始值可以设置属性和方法的原理"></a>2. 原始值可以设置属性和方法的原理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 包装类的执行过程</span><br><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">4</span>;   <br><span class="hljs-comment">// 原始值是坚决不能用属性的</span><br><br><span class="hljs-comment">// new Number(4).len = 3;</span><br>num.<span class="hljs-property">len</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 如果系统识别你要给原始值添加属性是不会报错的，则会调用 new Number(4).len = 3; 进行设置</span><br><span class="hljs-comment">// 设置完成后会立即 delete 删除此属性</span><br><br><span class="hljs-comment">// new Number(4).len   undefined // 删除后则访问不到了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-property">len</span>);<br><br><span class="hljs-comment">// 在我们访问字符串的length 属性时 new String(&#x27;abc&#x27;).length 将其长度进行返回。但这个长度不可以设置，如果进行手动设置则同样会走包装类的流程</span><br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> str.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// console.log(str.length);</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str).<span class="hljs-property">length</span>);<br><br><span class="hljs-comment">// 题目练习</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>str += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> test = <span class="hljs-title function_">typeof</span>(str);<br><span class="hljs-keyword">if</span>(test.<span class="hljs-property">length</span> == <span class="hljs-number">6</span>) &#123;<br>  test.<span class="hljs-property">sign</span> = <span class="hljs-string">&#x27;typeof 的返回结果可能是String&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">sign</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="19-原型"><a href="#19-原型" class="headerlink" title="19. 原型"></a>19. 原型</h2><blockquote><p>原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承原型的属性和方法，原型也是对象。原型只执行一遍。</p></blockquote><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Person.prototype  -- 原型</span><br><span class="hljs-comment">// Person.prototype = &#123;&#125; 就是Person构造函数构造出对象的公共祖先</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;hehe&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zs&#x27;</span>;  <span class="hljs-comment">// 如果构造函数中存在和原型中相同的属性，会优先使用调用构造中的属性</span><br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// 都继承了原型的 name 属性</span><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><br> <br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;   <span class="hljs-comment">// 也可以这样定义原型</span><br>    height : <span class="hljs-number">180</span>,<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="1-公用属性"><a href="#1-公用属性" class="headerlink" title="1. 公用属性"></a>1. 公用属性</h3><blockquote><p>利用原型的特点和概念，可以提取共有属性</p></blockquote><h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;   <span class="hljs-comment">// 将公有部分提取到原型中,可以提升性能，如果写在构造函数中每一次new都得执行一遍</span><br>    naem : <span class="hljs-string">&#x27;BMW&#x27;</span>,<br>    height : <span class="hljs-number">1400</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">color</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="2-原型的增删改查"><a href="#2-原型的增删改查" class="headerlink" title="2. 原型的增删改查"></a>2. 原型的增删改查</h3><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><h5 id="Person-prototype-age-18"><a href="#Person-prototype-age-18" class="headerlink" title="Person.prototype.age = 18"></a><code>Person.prototype.age = 18</code></h5><h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><h5 id="delete-Person-prototype-name"><a href="#delete-Person-prototype-name" class="headerlink" title="delete Person.prototype.name"></a><code>delete Person.prototype.name</code></h5><p>通过<code>delete parson1.name</code>删除的是自身对象中的属性，如果没有也不会报错。</p><h4 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h4><h5 id="Person-prototype-name-quot-changePrototypeName-quot"><a href="#Person-prototype-name-quot-changePrototypeName-quot" class="headerlink" title="Person.prototype.name = &quot;changePrototypeName&quot;"></a><code>Person.prototype.name = &quot;changePrototypeName&quot;</code></h5><p>需要通过原型来修改，如果<code>person1.name</code>会在自身对象中添加name 属性 并赋值 changePrototyeName。</p><h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><h5 id="person1-name"><a href="#person1-name" class="headerlink" title="person1.name"></a><code>person1.name</code></h5><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&quot;Zhang&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Howie&quot;</span>);<br><span class="hljs-comment">// 原型的 增、删、改、查</span><br><span class="hljs-comment">// Person.prototype.sex = &#x27;male&#x27;</span><br><span class="hljs-comment">// delete Person.prototype.sex</span><br><span class="hljs-comment">// Person.prototype.sex = &#x27;female&#x27;;  </span><br><span class="hljs-comment">// Person.prototype.sex = &#x27;male&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. constructor</h3><blockquote><p>查看对象的构造函数</p></blockquote><h5 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;<br>     <br>&#125;<br><span class="hljs-keyword">var</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// 这个方法也是在原型中继承过来的，可以手动更改</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Car.prototype</span><br><span class="hljs-comment">   &#123;constructor: ƒ&#125;</span><br><span class="hljs-comment">     constructor: ƒ Car() </span><br><span class="hljs-comment">     __proto__: Object </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 手动修改 constructor 属性的指向</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&quot;Zhang&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Howie&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="4-proto"><a href="#4-proto" class="headerlink" title="4.  __proto__"></a>4.  <code>__proto__</code></h3><blockquote><p>如何查看原型 -&gt; 隐式属性</p></blockquote><h5 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  查看 person1.__proto__ </span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zs&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  var this = &#123;</span><br><span class="hljs-comment">  __proto__ : Person.prototype, </span><br><span class="hljs-comment">  当发生 new 的时候，this对象中就会存在__proto__属性</span><br><span class="hljs-comment">    也就是说，如果 person1 查找属性，在Person构造中不存在的话，就会通过__proto__属性所绑定的原型来查找，这是系统提供的属性</span><br><span class="hljs-comment">    __proto__ 就是指向原型的指针</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">*/</span><br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h3 id="5-本章总结"><a href="#5-本章总结" class="headerlink" title="5. 本章总结"></a>5. 本章总结</h3><h5 id="我们需要牢记两点："><a href="#我们需要牢记两点：" class="headerlink" title="我们需要牢记两点："></a>我们需要牢记两点：</h5><p>①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；</p><p>② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p><p><code>__proto__</code>属性的作用就是当访问一个实例对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>指针所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点<code>null</code>，再往上找就相当于在<code>null</code>上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p><hr><h2 id="20-原型链"><a href="#20-原型链" class="headerlink" title="20. 原型链"></a>20. 原型链</h2><h4 id="如何构成原型链"><a href="#如何构成原型链" class="headerlink" title="如何构成原型链"></a>如何构成原型链</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 手动的更改构造函数的原型，连成一个链，称为原型链</span><br><br><span class="hljs-comment">// Grand.prototype 上指向 Object.prototype， Object.prototype是所有原型的最终原型  Object.prototype.__proto__ : null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Grand</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grandName</span> = <span class="hljs-string">&#x27;grand&#x27;</span><br>&#125;<br><span class="hljs-keyword">var</span> grand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grand</span>();<br><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = grand;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fatherName</span> = <span class="hljs-string">&#x27;father&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fortune</span> = &#123;<br>        <span class="hljs-attr">car1</span>: <span class="hljs-string">&#x27;visa&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = father;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sonName</span> = <span class="hljs-string">&#x27;son&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure><h4 id="原型链上属性的增删改查"><a href="#原型链上属性的增删改查" class="headerlink" title="原型链上属性的增删改查"></a>原型链上属性的增删改查</h4><ol><li>增删改当前属性只能使用当前属性的原型来操作</li><li><code>son.fortune.car2 = &quot;master&quot;</code> 利用原型中的引用类型可以修改</li></ol><h4 id="绝大多数对象最终都会继承自-Object-prototype-但是有个一除外-Object-create"><a href="#绝大多数对象最终都会继承自-Object-prototype-但是有个一除外-Object-create" class="headerlink" title="绝大多数对象最终都会继承自 Object.prototype 但是有个一除外 Object.create()"></a>绝大多数对象最终都会继承自 <code>Object.prototype</code> 但是有个一除外 <code>Object.create()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 执行</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 错误信息</span><br><span class="hljs-comment">* VM100:1 Uncaught TypeError: Object prototype may only be an Object or null: undefined</span><br><span class="hljs-comment">*    at Function.create (&lt;anonymous&gt;)</span><br><span class="hljs-comment">*    at &lt;anonymous&gt;:1:8</span><br><span class="hljs-comment">*/</span> <br>                        <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 创建出的对象不会继承自 Object.prototype</span><br></code></pre></td></tr></table></figure><h5 id="Object-create-原型-特性"><a href="#Object-create-原型-特性" class="headerlink" title="Object.create(原型, 特性)"></a><code>Object.create(原型, 特性)</code></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个对象并指定原型</span><br><span class="hljs-comment">// var obj = object.create(原型)</span><br><br><span class="hljs-keyword">var</span> obj = &#123;name : <span class="hljs-string">&#x27;zs&#x27;</span>, age : <span class="hljs-number">22</span>, sex : <span class="hljs-string">&#x27;male&#x27;</span>&#125;;<br><span class="hljs-keyword">var</span> student = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj);<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ls&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><hr><h2 id="21-拓展-toString"><a href="#21-拓展-toString" class="headerlink" title="21. 拓展 - toString()"></a>21. 拓展 - <code>toString()</code></h2><h3 id="toString"><a href="#toString" class="headerlink" title="toString()"></a><code>toString()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">原型都是继承自最终原型 object.prototype 的，而原型中存在一个toString()方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">引用值可以调用toString(),部分原始值也可以调用toString()(Number、String、Boolean这些类型可以通过包装类来实现调用toString()方法)，但是 undefined 和 null 是没有包装类的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">document.write() 会隐式调用 toString()方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">一下方法都重写了toString方法</span><br><span class="hljs-comment">  Number.prototype.toString()</span><br><span class="hljs-comment">  String.prototype.toString()</span><br><span class="hljs-comment">  Boolean.prototype.toString()</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(obj); <span class="hljs-comment">// 隐式的调用toString()方法，[Object object]</span><br><br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">// 手动重写 toString() </span><br>obj1.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hehe&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(obj1);<span class="hljs-comment">// 1. 报错，因为obj1没有原型、没有toString()方法</span><br></code></pre></td></tr></table></figure><h3 id="计算精度"><a href="#计算精度" class="headerlink" title="计算精度"></a>计算精度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 0.14 * 100 = 14.000000000000002;</span><br><span class="hljs-comment">// javascript 有计算精度不准的情况，应该避免小数运算</span><br></code></pre></td></tr></table></figure><h3 id="数学函数Math"><a href="#数学函数Math" class="headerlink" title="数学函数Math"></a>数学函数<code>Math</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">123.234</span>);   <span class="hljs-comment">// 124 向上取整，即使是 0.1 同样会进位</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">123.999</span>)； <span class="hljs-comment">// 123 向下取整 </span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();        <span class="hljs-comment">// 随机数 0-1的开区间数(&gt;0 * &lt;1)</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-comment">// var num  = Math.random().toFixed(2) * 100; // 同样会存在 精度不准 14.000000000000002 </span><br><span class="hljs-keyword">var</span> num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br><span class="hljs-comment">// 可正常计算的范围 小数点前 16　位，后　16 位</span><br></code></pre></td></tr></table></figure><h4 id="不可配置的属性"><a href="#不可配置的属性" class="headerlink" title="不可配置的属性"></a>不可配置的属性</h4><p>一旦经历了var操作所得出的属性，window,这种属性叫做不可配置的属性, 不可配置的属性 delete 不掉</p><h2 id="22-call-amp-apply"><a href="#22-call-amp-apply" class="headerlink" title="22. call &amp; apply"></a>22. <code>call &amp; apply</code></h2><blockquote><p>这两个方法可以改变<code>this</code>指向</p><p>区别：</p><ol><li><code>call</code> 需要把实参按照形参的个数传递进去</li><li><code>apply</code> 需要数组的形式，把实参传递进去（arguments类数组)</li></ol></blockquote><h5 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h5><p><code>函数执行 === 函数.call()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用其它函数实现自己的功能</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// test() === test.call();</span><br></code></pre></td></tr></table></figure><p>利用其它构造函数对自身实现属性的创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Test</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">&#x27;howie&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; name: &#x27;howie&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><p>如果一个构造函数完全涵盖了自己的需求，可以使用<code>call||apply</code>来对自己进行实现，可以减少编写新的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex </span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex;<br><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sex, tel, grade</span>) &#123;<br>  <span class="hljs-comment">// Student 完全涵盖了 Person 的需求，可以利用call/apply 来利用 Person 实现自己的需求</span><br>  <span class="hljs-comment">// new Student 之后，在当前函数中创建this对象，传入call中</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name , age, sex);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tel</span> = tel;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>&#125;<br><br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;howie&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">152</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用其它构造函数实现Car构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Wheel</span>(<span class="hljs-params">wheelSize, style</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> = style;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">wheelSize</span> = wheelSize;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sit</span>(<span class="hljs-params">c, sitColor</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = c;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sitColor</span> = sitColor;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Model</span>(<span class="hljs-params">height, width, len</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">len</span> = len;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">wheelSize, style, c, sitColor, height, width, len</span>) &#123;<br>  <span class="hljs-title class_">Wheel</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, wheelSize, style);<br>  <span class="hljs-title class_">Sit</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, c, sitColor);<br>  <span class="hljs-title class_">Model</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, height, width, len);<br>&#125;<br><span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;花里胡哨&#x27;</span>, <span class="hljs-string">&#x27;真皮&#x27;</span>, <span class="hljs-string">&#x27;棕色&#x27;</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1200</span>, <span class="hljs-number">1400</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="23-继承模式"><a href="#23-继承模式" class="headerlink" title="23. 继承模式"></a>23. 继承模式</h2><h4 id="继承发展史"><a href="#继承发展史" class="headerlink" title="继承发展史"></a>继承发展史</h4><ol><li>传统模式 》 原型链 》 借用构造函数(call&#x2F;apply) 》 共享原型 》 圣杯模式</li><li>缺点：<ol><li>传统模式： 过多的继承了没有的属性。</li><li>构造函数：不能继承借用构造函数的原型，每次构造函数都要多走一个函数。</li><li>共享原型：不能随便改动自己的原型。</li><li>圣杯模式：是目前在ES5及以下中比较完美的方式。</li></ol></li></ol><h5 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h5><p>传统模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 过多继承了不用的属性</span><br><span class="hljs-title class_">Grand</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&#x27;zs&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Grand</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> grand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grand</span>();<br><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = grand;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;father&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">father</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不能借用构造函数的原型</span><br><span class="hljs-comment">//  每次构造函数都要多走一个函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, sex</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, sex, grade</span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, sex);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>&#125;<br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;七年级一班&#x27;</span>);<br></code></pre></td></tr></table></figure><p>共有原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 缺点 继承者(Son、Target)没有自己的原型，不能对自己的原型进行修改和添加</span><br><br><span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&#x27;zs&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><br><br><span class="hljs-comment">// 2</span><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&#x27;zs&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Target, Origin</span>) &#123;<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>&#125;<br><span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Son</span>, <span class="hljs-title class_">Father</span>);<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure><p>圣杯模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">function F()&#123;&#125;;</span><br><span class="hljs-comment">F.prototype = Father.prototype;</span><br><span class="hljs-comment">Son.prototype = new F();</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lastName</span> = <span class="hljs-string">&#x27;zs&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Target, Origin</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">Uber</span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 标明它的超类，继承自谁</span><br>&#125;<br><span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Son</span>, <span class="hljs-title class_">Father</span>);<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;son&#x27;</span>;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><br><span class="hljs-comment">// son.__proto__ --&gt; new F().__proto__ --&gt; father.prototype</span><br></code></pre></td></tr></table></figure><p>圣杯进阶版（雅虎YUI)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 圣杯进阶版本(雅虎YUI)</span><br><span class="hljs-keyword">var</span> inherit = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;  <span class="hljs-comment">// 利用闭包私有化函数表达式</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">Target, Origin</span>) &#123;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constuctor</span> = <span class="hljs-title class_">Target</span>;<br>    <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">Uber</span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  &#125;<br>&#125;());<br></code></pre></td></tr></table></figure><hr><h2 id="24-拓展-模拟JQuery方法连续调用"><a href="#24-拓展-模拟JQuery方法连续调用" class="headerlink" title="24. 拓展 - 模拟JQuery方法连续调用"></a>24. 拓展 - 模拟<code>JQuery</code>方法连续调用</h2><h5 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $ = &#123;<br>  smoke : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;smokeing……&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;,<br>  drink : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;drinking……&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br><br>  &#125;,<br>  perm : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;perming……&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>&#125;<br>$.<span class="hljs-title function_">smoke</span>().<span class="hljs-title function_">drink</span>().<span class="hljs-title function_">perm</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="25-属性拼接"><a href="#25-属性拼接" class="headerlink" title="25. 属性拼接"></a>25. 属性拼接</h2><blockquote><p>对象除了<code>obj.prop</code>调用属性的方式外，还有一个方式</p><p><code>obj.name === obj[&#39;name&#39;]</code>；<code>obj.name</code> 内部也是会转成这个方式来执行。[“必须是字符串”]</p></blockquote><hr><h2 id="26-对象枚举"><a href="#26-对象枚举" class="headerlink" title="26. 对象枚举"></a>26. 对象枚举</h2><blockquote><p>如果去枚举(遍历 enumeration)一个对象</p></blockquote><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a><code>for in</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">var</span>  arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i ++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br><br><span class="hljs-comment">// 遍历对象  for in 遍历对象的专有方式,通过对象个数来控制循环圈数</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    name :<span class="hljs-string">&#x27;zs&#x27;</span>,<br>    age : <span class="hljs-number">123</span>,<br>    sex : <span class="hljs-string">&#x27;male&#x27;</span>,<br>    height : <span class="hljs-string">&#x27;180&#x27;</span>,<br>    weight : <span class="hljs-number">75</span><br>&#125;<br><br><span class="hljs-comment">// 循环对象，prop(任意名称)变量存储了当前循环对象的属性(prop 是字符串类型)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> obj) <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * console.log(obj.prop);</span><br><span class="hljs-comment"> * 这是会打印 5 个undefined，因为这里把 prop 当做属性来调用,而obj中并没有加这个属性 ---&gt; obj[&#x27;prop&#x27;];</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[prop]); <span class="hljs-comment">// prop 是一个字符串类型的变量</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="hanOwnproperty"><a href="#hanOwnproperty" class="headerlink" title="hanOwnproperty"></a><code>hanOwnproperty</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hasOwnProperty 过滤原型上的属性和方法</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    name :<span class="hljs-string">&#x27;zs&#x27;</span>,<br>    age : <span class="hljs-number">123</span>,<br>    sex : <span class="hljs-string">&#x27;male&#x27;</span>,<br>    height : <span class="hljs-string">&#x27;180&#x27;</span>,<br>    weight : <span class="hljs-number">75</span>,<br>    __proto__ : &#123;   <span class="hljs-comment">// 如果有原型属性或者方法，单纯使用 for in 也会把原型中的属性和方法遍历出来</span><br>        lastName : <span class="hljs-string">&#x27;ls&#x27;</span>，<br>        __proto__ : object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-comment">// for in 只会延展到自定义原型，系统定义不会打印</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-comment">// *hasOwnProperty() 判断当前属性是否是本身而非原型的属性，如果是本身则返回 true,反之 false</span><br>  <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123; <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[prop]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个属性是否可以访问，判断属性是否是某个对象上的（不区分原型）</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;howie&#x27;</span>,<br>  age : <span class="hljs-number">18</span>, <span class="hljs-comment">// 不要问，问就是18岁</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hobby&#x27;</span> <span class="hljs-keyword">in</span> obj); <span class="hljs-comment">// 是否可以通过obj调用到该属性，如果可以返回 true 反之 false</span><br></code></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  公式: A instanceof B  A</span><br><span class="hljs-comment">  官方描述 : 对象 A 是不是 B 对象构造出来的，是返回 true，反之返回 false</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 为 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// 依然为 true</span><br><span class="hljs-comment">// 官方描述不充足 </span><br><span class="hljs-comment">// * A 对象的原型链上有没有 B 的原型</span><br></code></pre></td></tr></table></figure><hr><h2 id="27-拓展-类型判断-amp-克隆"><a href="#27-拓展-类型判断-amp-克隆" class="headerlink" title="27. 拓展 - 类型判断&amp;克隆"></a>27. 拓展 - 类型判断&amp;克隆</h2><p>引用值类型判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [] || &#123;&#125;; <br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">如何判断一个变量是数组还是对象</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1. 使用 变量.constructor 返回它的构造器是什么</span><br><span class="hljs-comment">2. 变量 instanceof 对象</span><br><span class="hljs-comment">*3. toString() </span><br><span class="hljs-comment">每个函数都有原型 而原型最终都是继承自 Object.prototype,</span><br><span class="hljs-comment">我们可以利用 Object.prototype.toString() 方法，</span><br><span class="hljs-comment">改变方法内的 this 指向 Object.prototype.toString.call(&#123;&#125;/[]);来判断属于哪种类型</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>克隆</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  name : <span class="hljs-string">&#x27;Howie&#x27;</span>,<br>  age : <span class="hljs-number">18</span>,<br>  say : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i am Howie&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;吃&#x27;</span>, <span class="hljs-string">&#x27;喝&#x27;</span>, <span class="hljs-string">&#x27;玩&#x27;</span>, <span class="hljs-string">&#x27;乐&#x27;</span>],<br>&#125;<br><span class="hljs-keyword">var</span> copy = &#123;&#125;<br><span class="hljs-comment">// 克隆</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (target, origin) &#123;<br>  <span class="hljs-keyword">var</span> target = target || &#123;&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> obj) &#123;<br>    copy[prop] = obj[prop];<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 深度克隆</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    name : <span class="hljs-string">&#x27;howie&#x27;</span>,<br>    age : <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;吃&#x27;</span>, <span class="hljs-string">&#x27;喝&#x27;</span>, <span class="hljs-string">&#x27;玩&#x27;</span>,<span class="hljs-string">&#x27;乐&#x27;</span>]<br>  &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">origin, target</span>) &#123;<br>  <span class="hljs-keyword">var</span> target = target || &#123;&#125;;  <span class="hljs-comment">// 容错</span><br>  <span class="hljs-keyword">var</span> objectTypes = &#123;<br>    object : <span class="hljs-string">&#x27;[object Object]&#x27;</span>,<br>    array : <span class="hljs-string">&#x27;[object Array]&#x27;</span><br>  &#125;,<br>  verifyType = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> origin) &#123;<br>    <span class="hljs-keyword">if</span>(origin.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123; <span class="hljs-comment">// 把原型中的属性和方法过滤掉</span><br>      <span class="hljs-keyword">if</span>(origin[prop] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">typeof</span>(origin[prop]) == <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[prop] = verifyType.<span class="hljs-title function_">call</span>(origin[prop]) == objectTypes.<span class="hljs-property">object</span>? &#123;&#125; : [];<br>        <span class="hljs-title function_">deepClone</span>(origin[prop], target[prop]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[prop] = origin[prop];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-keyword">var</span> copy = <span class="hljs-title function_">deepClone</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);<br>copy.<span class="hljs-property">hobby</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;学习&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="28-this"><a href="#28-this" class="headerlink" title="28. this"></a>28. <code>this</code></h2><blockquote><p>函数编译过程中的 <code>this</code> 指向 <code>window</code></p><p>全局作用域里的 <code>this</code> 指向 <code>window</code></p><p><code>call / apply</code> 可以改变函数运行时的 <code>this</code> 指向</p><p><code>obj.func()</code> func()里面的 <code>this</code> 指向 <code>obj</code>，通俗来说就是谁调用此方法，方法内部的<code>this</code>就指向谁</p></blockquote><h5 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">c</span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 这种称为空执行 方法当中的 this 指向window</span><br><br><span class="hljs-comment">/* 预编译生成执行期上下文</span><br><span class="hljs-comment">  AO&#123;</span><br><span class="hljs-comment">    arguments : [1],   其实里边还有 arguments 和 this 属性，默认 this 指向 window</span><br><span class="hljs-comment">    this : window,</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    c : 1,</span><br><span class="hljs-comment">    a : undefined,</span><br><span class="hljs-comment">    b : fu()</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 函数经过 new 之后，会隐式的创建出 this 对象，并更改它的指向 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">c</span>) &#123;<br>    <span class="hljs-comment">// var this = &#123;&#125; --&gt; Object.create(test.prototype); </span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="29-callee-amp-caller"><a href="#29-callee-amp-caller" class="headerlink" title="29. callee &amp; caller"></a>29. <code>callee &amp; caller</code></h2><p><code>arguments.callee</code> 表示函数自身的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>&#125;<br><span class="hljs-title function_">test</span>();<br><br><span class="hljs-comment">// 使用场景，例如需要使用立即执行函数做一些初始化操作，求 n 的阶乘</span><br><span class="hljs-keyword">var</span> result = (<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 立即执行函数是没有函数名称的，所以在使用递归时需要使用 arguments.callee 来代替函数本身</span><br>    <span class="hljs-keyword">return</span> n * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(n - <span class="hljs-number">1</span>);  <br>&#125;(<span class="hljs-number">100</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><p><code>function.caller</code> 函数被调用时的函数环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这不是 arguments的属性，其本身指函数在哪个执行环境下被调用，经常和 callee 混考</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">demo</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(demo.<span class="hljs-property">caller</span>); <span class="hljs-comment">// 返回 test函数引用</span><br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="30-数组"><a href="#30-数组" class="headerlink" title="30. 数组"></a>30. 数组</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="1-数组字面量"><a href="#1-数组字面量" class="headerlink" title="1. 数组字面量"></a>1. 数组字面量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-comment">// 数组字面量</span><br></code></pre></td></tr></table></figure><h4 id="2-系统构造函数"><a href="#2-系统构造函数" class="headerlink" title="2. 系统构造函数"></a>2. 系统构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 系统构造函数</span><br></code></pre></td></tr></table></figure><h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>];  <span class="hljs-comment">// 表示一个值为 10</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 表示数组的长度为 10</span><br></code></pre></td></tr></table></figure><h4 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4. 扩展"></a>4. 扩展</h4> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, , , <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// 稀松数组</span><br></code></pre></td></tr></table></figure><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr[num] <span class="hljs-comment">// 溢出读结果均为undefined</span><br>arr[num] = xxx; <span class="hljs-comment">// 可以溢出写</span><br></code></pre></td></tr></table></figure><h3 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h3><h4 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h4><ol><li><code>push()</code>向数组末尾添加数据，并返回新数组(不限个数)</li><li><code>pop()</code>剪切数组末尾值，并返回剪切值</li><li><code>unshift()</code>向数组顶部添加数据，并返回新数组(不限个数)</li><li><code>shift()</code>剪切数据头部数据，并返回剪切值</li><li><code>reverse()</code>逆转数组</li><li><code>splice()</code>截取，填充</li><li><code>sort()</code>数组排序，默认是升序</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// push、pop、shift、unshift、sort、reverse、splice</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 向数组末尾添加数据，并返回新数组(不限个数)</span><br><br>arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 剪切数组末尾值，并返回剪切值()</span><br><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 向数组顶部添加数据，并返回新数组(不限个数)</span><br><br>arr.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 剪切数据头部数据，并返回剪切值</span><br><br>arr.<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// 逆转数组</span><br><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-string">&#x27;开始位置&#x27;</span>,<span class="hljs-string">&#x27;截取长度&#x27;</span>,<span class="hljs-string">&#x27;在切口处添加的新数据&#x27;</span>) <span class="hljs-comment">// 截取，填充</span><br><span class="hljs-comment">// arr.splice(1, 1); 从第一位开始，截取一位 结果为:[1, 3, 4, 5];</span><br><br>arr.<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// 数组排序，默认是升序</span><br><br><span class="hljs-comment">// sort() 它是按照ascii码来比较，和字符串相同，可以给方法写一个回调函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">书写回调的规则：</span><br><span class="hljs-comment">1.必须有两个参数</span><br><span class="hljs-comment">2.为负数时前面的数在前</span><br><span class="hljs-comment">3.为0时不动位置</span><br><span class="hljs-comment">4.为正数时前面的数在后</span><br><span class="hljs-comment">*/</span> <br><br>arr.<span class="hljs-title function_">soft</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-comment">// 升序排序</span><br>    <span class="hljs-keyword">if</span>(a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &gt; b) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;)；<br><span class="hljs-comment">// 简化函数</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h4><ol><li><code>concat()</code> 将两个数组连接，并返回新数组</li><li><code>slice()</code>截取 从数组的该位开始截取 截取到数组的该位</li><li><code>json()</code>用什么分隔符将数组拆分成字符串，规定传值要使用字符串类型的,如果不写参数默认以“,”逗号分隔</li><li><code>split</code>（字符串方法）按什么分隔符将字符串转换成数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// concat、join、split、toString、slice</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>];<br><br><span class="hljs-keyword">var</span> arr3 = arr1.<span class="hljs-title function_">concat</span>(arr2); <span class="hljs-comment">// 将两个数组连接，并返回新数组</span><br><br>arr1.<span class="hljs-title function_">slice</span>(从数组的该位开始截取，截取到数组的该位); <span class="hljs-comment">// 截取 两个参数</span><br>arr1.<span class="hljs-title function_">slice</span>(从数组的该位开始截取); <span class="hljs-comment">// 一个参数会截取到最后</span><br>arr1.<span class="hljs-title function_">slice</span>()； <span class="hljs-comment">// 截取整个数组</span><br><br>arr1.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// 用什么分隔符将数组拆分成字符串，规定传值要使用字符串类型的,如果不写参数默认以“,”逗号分隔</span><br><br><span class="hljs-comment">// 字符串的方法</span><br>arr1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// 按什么分隔符将字符串转换成数组</span><br> <br><span class="hljs-comment">// 以上都是不可改变原数组的，看结果需要查看方法返回值</span><br></code></pre></td></tr></table></figure><h4 id="模拟-push方法"><a href="#模拟-push方法" class="headerlink" title="模拟 push方法"></a>模拟 <code>push</code>方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 直接覆盖系统方法</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;push被我重写了&#x27;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i ++) &#123;<br>    <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="31-类数组"><a href="#31-类数组" class="headerlink" title="31. 类数组"></a>31. 类数组</h2><blockquote><p>常见的类数组有函数中的 <code>arguments</code> 和 使用 <code>document.getElementsBy...</code></p></blockquote><h4 id="类数组的书写规范"><a href="#类数组的书写规范" class="headerlink" title="类数组的书写规范"></a>类数组的书写规范</h4><ol><li>类数组属性名必须是索引值（数字）。</li><li>必须加上 langth 属性。</li><li>最好加上 push 方法。</li></ol><h5 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&quot;0&quot;</span> : <span class="hljs-string">&quot;a&quot;</span>,<br>  <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-string">&quot;b&quot;</span>,<br>  <span class="hljs-string">&quot;2&quot;</span> : <span class="hljs-string">&quot;c&quot;</span>,<br>  <span class="hljs-string">&quot;length&quot;</span> : <span class="hljs-number">3</span>,<br>  <span class="hljs-string">&quot;push&quot;</span> : <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span>，<br>  <span class="hljs-string">&quot;splice&quot;</span> : <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span> <span class="hljs-comment">// 这个属性可以把对象的&#123;&#125;(花括号)该称[](方括号)</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.可以利用属性名模拟数组特征</span><br><span class="hljs-comment">2.可以动态的增长length属性</span><br><span class="hljs-comment">3.如果强行让类数组调用push方法，则会根据 langth 属性值的位置进行属性的扩展</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>类数组的好处就是，可以对象和数组的特性拼到一起，<code>arguments</code>实参列表是一个类数组。</p><hr><h2 id="32-try-catch"><a href="#32-try-catch" class="headerlink" title="32. try-catch"></a>32. <code>try-catch</code></h2><blockquote><p><code>try-catch</code>可以帮助我们在程序中捕获异常</p></blockquote><h5 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 try 里面发生的错误，不会执行错误后的 try 里面的代码</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 正常执行</span><br><span class="hljs-keyword">try</span>&#123;  <span class="hljs-comment">// 尝试执行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">// 正常执行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( c );<span class="hljs-comment">// 报错，但不抛出错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;d&#x27;</span>);<span class="hljs-comment">// 不执行，因为以上有代码报错</span><br>&#125;<span class="hljs-keyword">catch</span>(e) &#123;  <span class="hljs-comment">// 错误捕捉，如果try&#123;&#125;中不存在错误，将不会执行</span><br>    <span class="hljs-comment">// e错误对象 === error === error.message &amp;&amp; error.name</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27; &#x27;</span>+ e.<span class="hljs-property">message</span>);   <br>    <span class="hljs-comment">// 错误名称(类型)e.name: ReferenceError  错误信息 e.message：c is not defined </span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;e&#x27;</span>);  <span class="hljs-comment">// 正常执行</span><br></code></pre></td></tr></table></figure><h4 id="Error-name-的报错信息"><a href="#Error-name-的报错信息" class="headerlink" title="Error.name 的报错信息"></a><code>Error.name</code> 的报错信息</h4><ol><li><code>EvalError</code>：eval() 的使用与定义不一致。</li><li><code>RangeError</code>: 数值越界。</li><li><code>ReferenceError</code>: 非法或不能识别的引用数值。例如：未经声明就使用的变量。</li><li><code>SyntaxError</code>: 发生语法解析错误，例如：使用了中文字符进行编码。</li><li><code>TypeError</code>: 操作数据类型错误，例如：在 ES5 严格模式下使用 arguments.callee</li><li><code>URLError</code>: URL处理函数使用不当</li></ol><hr><h2 id="32-Error"><a href="#32-Error" class="headerlink" title="32. Error"></a>32. Error</h2><ol><li>语法错误。</li><li>逻辑错误。</li><li>一个代码块发生错误，不会影响其他代码块的执行。</li></ol><hr><h2 id="33-ES5-严格模式"><a href="#33-ES5-严格模式" class="headerlink" title="33. ES5 严格模式"></a>33. ES5 严格模式</h2><blockquote><p>目前发布的javascript 版本有 es3.0&#x2F;es5.0&#x2F;es6.0&#x2F;es7.0ing…</p><p>现在的浏览器依然是基于 es3.0 + es5.0的新增方法使用的，两者产生冲突的使用的是es3.0</p><p>如果使用es5.0的严格模式，则强制浏览器在冲突部分使用es5.0的方法</p><p>需要写在页面逻辑(全局严格模式)或者函数逻辑(局部严格模式)的最顶端</p></blockquote><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p><code>&quot;use strict&quot;</code> 启用 ES5 的全新规范，不在兼容 ES3 的一些方法。</p><p>严格模式有两种使用方式， 一种是全局严格模式，另一种是局部严格模式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 全局严格模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-javascript">&quot;use strict&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;严格模式&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>); <span class="hljs-comment">// 严格模式中对 callee 不再支持</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 局部严格模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&quot;use sttict&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> ,<span class="hljs-number">3</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动方式是一行字符串，因为不会对不兼容的浏览器产生影响，提升容错。</p><p>严格模式下不支持的方法和书写规则</p><ol><li><code>with</code>: with(){} 方法会修改作用域链，不推荐使用，过于消耗性能。</li><li><code>arguemnts.callee</code>: </li><li><code>fn.caller</code></li><li>变量赋值前必须声明。</li><li>局部<code>this</code>必须被赋值（Person.call(null &#x2F; undefined) 赋值是什么就是什么），预编译时 <code>this</code>不再指向 <code>window</code></li><li>拒绝重复属性和参数</li></ol><p><a href="%E4%B8%80%E4%B8%AA%60&lt;script&gt;%60%E6%A0%87%E7%AD%BE%E5%8F%AA%E8%83%BD%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B%E5%84%BF%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%81%9A%E5%A4%96%E9%93%BE%E5%92%8C%E5%86%85%E8%81%94">注意^</a>: 启动 ES5 严格模式，”use strict”; 必须写在逻辑的最顶端。</p><hr><h2 id="34-DOM"><a href="#34-DOM" class="headerlink" title="34. DOM"></a>34. DOM</h2><blockquote><p>什么是DOM?</p><ol><li>DOM 》 Document Object Model。</li><li>DOM 定义了表示和修改文档所需的方法。DOM 对象即宿主对象，有浏览器厂商定义，用来操作 HTML 和 XML 功能的一类对象的集合。也有人称 DOM 是对 HTML 以及 XML 的标准接口。</li><li>Document 代表整个文档。</li></ol></blockquote><h3 id="DOM-的基本操"><a href="#DOM-的基本操" class="headerlink" title="DOM 的基本操"></a>DOM 的基本操</h3><h4 id="1-对-DOM-节点的增删改查"><a href="#1-对-DOM-节点的增删改查" class="headerlink" title="1. 对 DOM 节点的增删改查"></a>1. 对 DOM 节点的增删改查</h4><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><ul><li><p>查看元素节点</p><ul><li><code>document.getElementById();</code>  通过ID获取元素。(IE8及以下的浏览器是不区分大小写的)</li><li>.<code>getElementsByTagName(); </code>  通过标签名获取元素的集合放在类数组中</li><li><code>.getElementsByName();</code>   需注意，只有部分标签 name 可生效（表单、表单元素，img，iframe），目前各浏览器对其他标签兼容情况得到了优化，但是不常用</li><li><code>.getElementsByClassName();</code>   通过类名选取元素，IE8及以下IE版本中没有</li><li><code>.querySelector(&#39;div &gt; span &gt; ...&#39;); </code>  css选择器，选择一个，在ie7及以下版本中没有</li><li><code>.querySelectorAll(&#39;div &gt; span &gt; ...&#39;);</code>  css选择器，选择一组，在ie7及以下版本中没有</li></ul><p><a href="%E4%B8%80%E4%B8%AA%60&lt;script&gt;%60%E6%A0%87%E7%AD%BE%E5%8F%AA%E8%83%BD%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B%E5%84%BF%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%81%9A%E5%A4%96%E9%93%BE%E5%92%8C%E5%86%85%E8%81%94">注意^</a>: querySelector 和 querySelectorAll 都是不推荐使用的，因为他们选择出来的都是不是实时的，是静态的是副本。（例如：n 个 div 删除其中一个，用getElement……选中的元素是 n - 1 个， 但是用queryS……依然是 n 个。</p></li><li><p>遍历节点树 </p><ul><li><p><code>parentNode</code> - 父节点（最顶端的parentNode 为 #document）</p></li><li><p><code>childNodes</code> - 子节点们，会选出所有节点(下面会有节点类型的介绍)</p></li><li><p><code>firstChild</code> - 第一个子节点</p></li><li><p><code>lastChild</code> - 最后一个子节点</p></li><li><p><code>nextSiBling</code> - 下一个兄弟元素节点</p></li><li><p><code>previousSiBling</code> - 上一个兄弟元素节点</p></li></ul></li><li><p>基于元素节点树的遍历（除去 children外，其它在IE9及以下不兼容）</p><ul><li><code>parentElement</code> - 父元素节点(IE9及以下不兼容)</li><li><code>children</code> - 子元素节点</li><li><code>node.childElementCount === node.children.length</code> 当前元素节点的子元素个数(IE9及以下不兼容)</li><li><code>firstElementChild</code> - 第一个元素子节点（IE9及以下不兼容）</li><li><code>lastElementChild</code> - 最后一个元素子节点 （IE9及以下不兼容）</li><li><code>nextElementSiBling</code> - 下一个兄弟元素 (IE9及以下不兼容)</li><li><code>previousElementSiBling</code> - 上一个兄弟元素 (IE9及以下不兼容)</li></ul></li></ul><h5 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h5><ul><li><code>document.createElement();</code>                 创建元素节点</li><li><code>document.createTextNode(); </code>               创建文本节点</li><li><code>document.createComment(); </code>                 创建注释节点</li><li><code>document.createDocumentFragment(); </code> 创建文档碎片节点</li></ul><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul><li><p><code>PARENTNODE.appendChild();</code>       在哪个父节点插入节点。类似push操作，把已有的元素插入到另一个元素时，执行的是剪切操作</p></li><li><p><code>PARENTNODE.insertBefore(a, b); </code>  将 a 元素插入到父级元素 b 元素之前, insert a before b</p></li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li><code>parent.removeChild();</code>  父节点删除子节点，返回剪切结果</li><li><code>child.remove(); </code> 子节点调用删除自身的方法，直接删除</li></ul><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li>parent.replaceChild(newEl , originEl);  拿新元素替换旧元素</li></ul><hr><h4 id="2-节点类型-节点类型值"><a href="#2-节点类型-节点类型值" class="headerlink" title="2. 节点类型 - 节点类型值"></a>2. 节点类型 - 节点类型值</h4><ul><li><p>元素节点 - 1</p></li><li><p>属性节点 - 2</p></li><li><p>文本节点 - 3</p></li><li><p>注释节点 - 8</p></li><li><p>document - 9</p></li><li><p>documentFragment(文档碎片) - 11</p></li></ul><hr><h5 id="3-节点的四个属性"><a href="#3-节点的四个属性" class="headerlink" title="3. 节点的四个属性"></a>3. 节点的四个属性</h5><ul><li><p>nodeName - 元素的标签名，以大写的形式表示，只读</p></li><li><p>nodeValue - Text 节点或 Comment 节点的文本内容，可读写</p></li><li><p>nodeType - 该节点的类型，只读</p></li><li><p>attributes - Element 节点的属性集合</p></li></ul><hr><h5 id="4-节点的一个方法"><a href="#4-节点的一个方法" class="headerlink" title="4. 节点的一个方法"></a>4. 节点的一个方法</h5><ul><li>Node.hasChildNodes(); - 判断是否有子节点</li></ul><hr><h5 id="5-DOM节点树"><a href="#5-DOM节点树" class="headerlink" title="5.DOM节点树"></a>5.DOM节点树</h5><p>文档中元素的继承关系，如下图。</p><p><img src="/JavascriptNotesImages/DOM%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="DOM 继承关系图"></p><ul><li><p>getElementById方法定义在 Document.prototype 上，即Element节点上不能使用。</p></li><li><p>getElementByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用（xml document.Element）</p></li><li><p>getElementByTagName方法定义在Document.prototype 和 Element.prototype 上</p></li><li><p>HTMLDocument.prototype定义了一些常用的属性，body、head分别指代HTML文档中的<code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签</p><ul><li><code>document.body</code>: body 标签</li><li><code>document.head</code>: head 标签</li></ul></li><li><p>Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在HTML文档中总是指代</p><ul><li><code>&lt;html&gt;</code> 元素</li></ul></li><li><p>getElementsByClassName、querySelector、querySelectorAll 在Document、Element类中均有定义。</p></li></ul><hr><h5 id="6-Element-节点的一些属性"><a href="#6-Element-节点的一些属性" class="headerlink" title="6. Element 节点的一些属性"></a>6. Element 节点的一些属性</h5><ul><li><p>innerHTML: 写入、读取 HTML结构，默认会覆盖原有内容，可以使用 +&#x3D; 先取值再赋值</p></li><li><p>innerText:（老版本火狐不兼容） &#x2F; textContent(老版本IE不好使) 写入、读取 文本</p></li></ul><hr><h5 id="7-Element-节点的一些方法"><a href="#7-Element-节点的一些方法" class="headerlink" title="7. Element 节点的一些方法"></a>7. Element 节点的一些方法</h5><ul><li>el.setAttribute(‘propName’, ‘propValue’);  写入行间属性，可以设置系统没有的</li><li>el.getAttribute(‘propName’)  读取行间属性</li><li>改变Class时还可以使用 dom.className</li></ul><hr><h2 id="35-Date-日期对象"><a href="#35-Date-日期对象" class="headerlink" title="35. Date 日期对象"></a>35. <code>Date</code> 日期对象</h2><blockquote><p>日期对象中使用的方法都是系统定义好的</p><p>语法： <code>var date = new Date()</code></p></blockquote><h4 id="Date-对象中的方法"><a href="#Date-对象中的方法" class="headerlink" title="Date 对象中的方法"></a>Date 对象中的方法</h4><ul><li><p><code>date.getDate();</code>         返回今天是这个月的第几天</p></li><li><p><code>date.getDay();</code>          返回今天是这周的第几天，从零开始，0 表示 星期天</p></li><li><p><code>date.getMonth();</code>        返回月份，0 ~ 11 操作时需要加 1</p></li><li><p><code>date.getFullYear();</code>     返回四位数的年份</p></li><li><p><code>date.getHours();</code>        返回小时</p></li><li><p><code>date.getMinutes();</code>      返回分钟</p></li><li><p><code>date.getSeconds();</code>      返回秒</p></li><li><p><code>date.getMilliseconds();</code> 返回毫秒</p></li><li><p><code>date.getTime();</code>         返回自 1970 年 1 月 1 日至今的毫秒数（计算机的纪元时间）</p></li></ul><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p><code>new Date().getTime();</code> 作为时间戳</p><hr><h2 id="36-定时器-amp-定时循环器"><a href="#36-定时器-amp-定时循环器" class="headerlink" title="36. 定时器&amp;定时循环器"></a>36. 定时器&amp;定时循环器</h2><h5 id="setInterval定时循环器-精度不准确"><a href="#setInterval定时循环器-精度不准确" class="headerlink" title="setInterval定时循环器, 精度不准确"></a><code>setInterval</code>定时循环器, 精度不准确</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 间隔1000毫秒执行一次循环 1000毫秒 == 1秒</span><br><br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// setInterval 会返回一个唯一标识给 timer 用来清除定时循环器 </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>); <br><span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 清除定时循环，可以在方法写在内部，到一定条件时清除</span><br><br><span class="hljs-keyword">var</span> timer = <span class="hljs-number">1000</span>;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;, timer); <span class="hljs-comment">// 这里的 timer 只识别一次，后续修改不起作用</span><br>timer = <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><h5 id="setTimeout定时器"><a href="#setTimeout定时器" class="headerlink" title="setTimeout定时器"></a><code>setTimeout</code>定时器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;时间到了&#x27;</span>)；<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 使用方法与 定时循环器 相同</span><br></code></pre></td></tr></table></figure><hr><h2 id="37-获取窗口属性和-dom元素尺寸"><a href="#37-获取窗口属性和-dom元素尺寸" class="headerlink" title="37. 获取窗口属性和 dom元素尺寸"></a>37. 获取窗口属性和 dom元素尺寸</h2><h4 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h4><ul><li><p><code>window.pageXOffset/pageYOffset</code></p><ul><li><p>IE8及以下浏览器不兼容</p></li><li><p>IE8及以下浏览器查看滚动距离</p><ul><li><code>document.body.scrollLeft/scrollTop</code></li><li><code>document.documentElement.scorllLeft/Top</code>: ie7&#x2F;6</li></ul></li><li><p>方法封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getScrollOffset</span> () &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">pageXOffset</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      x : <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageXOffset</span>,<br>      y : <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 兼容IE8及以下浏览器</span><br>      x : <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollLeft</span>,<br>      y : <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="查看视口尺寸"><a href="#查看视口尺寸" class="headerlink" title="查看视口尺寸"></a>查看视口尺寸</h4><ul><li><p><code>window.innerWidth/innerHeight</code></p><ul><li>IE8 及以下浏览器不兼容</li></ul></li><li><p><code>document.documentElement.clientWidth/clientHeight</code></p><ul><li>标准模式下，任意浏览器都兼容</li></ul></li><li><p><code>document.body.clientWidth/clientHeight</code></p><ul><li>适用于怪异模式</li></ul></li><li><p>代码封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getViewportOffset</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      w : <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>      h : <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">compatMode</span> === <span class="hljs-string">&quot;BackCompat&quot;</span>) &#123; <span class="hljs-comment">// BackCompat 为怪异模式</span><br>      <span class="hljs-keyword">return</span> &#123;<br>        w : <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>,<br>        h : <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        w : <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>,<br>        h : <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span><br>      &#125;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="查看元素的几何尺寸（基本报废）"><a href="#查看元素的几何尺寸（基本报废）" class="headerlink" title="查看元素的几何尺寸（基本报废）"></a>查看元素的几何尺寸（基本报废）</h4><ul><li><code>documentElement.getBoundingClientRect()</code><ul><li>兼容性很好</li><li>该方法返回一个对象，对象里面有left、top、right、bottom等属性。left和top代表元素左上角的X和Y坐标，right和bottom代表元素右下角的x和y坐标</li><li>height 和 width 属性老版本IE并未实现</li><li>返回的结果并不是 <strong>实时的</strong></li></ul></li></ul><h4 id="查看元素尺寸（视觉上的尺寸-包含padding、border-等宽高）"><a href="#查看元素尺寸（视觉上的尺寸-包含padding、border-等宽高）" class="headerlink" title="查看元素尺寸（视觉上的尺寸,包含padding、border 等宽高）"></a>查看元素尺寸（视觉上的尺寸,包含padding、border 等宽高）</h4><ul><li><code>dom.offsetWidth - dom.offsetHeight</code></li></ul><h4 id="查看元素的位置"><a href="#查看元素的位置" class="headerlink" title="查看元素的位置"></a>查看元素的位置</h4><ul><li><code>dom.offsetLeft - dom.offsetTop</code><ul><li>对于无定位父级的元素，返回相对于文档的坐标。对于定位的父级返回相对于最近的有定位的父级的坐标(只要父级有定位，不论这个距离是如何生成的，margin也可以)</li></ul></li><li><code>dom.offsetParent</code><ul><li>返回最近的有定位打的父级，如无，返回 body，body.offsetParent 返回 null</li></ul></li></ul><h4 id="设置滚动条滚动"><a href="#设置滚动条滚动" class="headerlink" title="设置滚动条滚动"></a>设置滚动条滚动</h4><p>window 上有三个方法</p><ol><li><code>scroll(x, y)</code>: x &#x2F; y 滚动条滚动设置距离的位置</li><li><code>scrollTo(x, y)</code>: 同上</li><li><code>scrollBy(x, y)</code>: 会在之前的数据基础之上做累加滚动距离</li></ol><hr><h2 id="38-脚本化CSS"><a href="#38-脚本化CSS" class="headerlink" title="38. 脚本化CSS"></a>38. 脚本化CSS</h2><h4 id="读写元素-css-属性"><a href="#读写元素-css-属性" class="headerlink" title="读写元素 css 属性"></a>读写元素 css 属性</h4><ul><li><code>dom.style.prop</code><ul><li><p>可读写行间样式（仅限于行间样式），没有任何兼容性问题，碰到 float 这样的关键字属性，前面应加 css </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">style</span>.<span class="hljs-property">cssFloatLeft</span><br></code></pre></td></tr></table></figure></li><li><p>复合属性可以最好可以拆解</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid red&quot;</span>;  <span class="hljs-comment">/* 复合属性 */</span> <br>el.<span class="hljs-property">style</span>.<span class="hljs-property">borderWidth</span> = <span class="hljs-string">&quot;1px&quot;</span>;<br>el.<span class="hljs-property">style</span>.<span class="hljs-property">borderStyle</span> = <span class="hljs-string">&quot;solid&quot;</span>;<br>el.<span class="hljs-property">style</span>.<span class="hljs-property">borderColor</span> = <span class="hljs-string">&quot;red&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>组合单词变成小驼峰式命名法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// border-width</span><br>borderWidth = <span class="hljs-string">&quot;1px&quot;</span>;<br>backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>写入的值必须是字符串</p></li></ul></li></ul><hr><h4 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h4><ul><li><p><code>window.getComputedStyle(elem, null);</code> null: 可以获取指定伪元素样式表</p><ul><li>获取的是元素最后展示的值,计算样式只读,不区分是否是行间、内联和外部</li><li>IE8及以下不兼容<ul><li><code>elem.currentStyle.prop</code><ul><li>计算样式只读,IE独有,返回的计算样式的值不是经过转换的绝对值</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(elem, <span class="hljs-literal">null</span>).<span class="hljs-property">width</span>; <span class="hljs-comment">// 获取元素的宽</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(box, <span class="hljs-string">&#x27;after&#x27;</span>).<span class="hljs-property">width</span>; <span class="hljs-comment">// 获取元素中伪元素的宽</span><br></code></pre></td></tr></table></figure></li><li><p>脚本化样式表</p><ul><li><code>document.styleSheets</code><ul><li>该属性存储了 HTML 文档里面所有 CSS 样式表的集合</li></ul></li></ul></li></ul><hr><h2 id="39-事件"><a href="#39-事件" class="headerlink" title="39. 事件"></a>39. 事件</h2><h3 id="绑定事件处理函数和执行环境"><a href="#绑定事件处理函数和执行环境" class="headerlink" title="绑定事件处理函数和执行环境"></a>绑定事件处理函数和执行环境</h3><h4 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a><code>onclick</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;demo&#x27;</span>);<br><br>div.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了div&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  这种方式是最原始、兼容性最好的绑定方式</span><br><span class="hljs-comment">  缺点就是，只能为dom元素绑定一个 事件处理函数，因为属于赋值，后面的会覆盖之前的</span><br><span class="hljs-comment">  这种编写方式等同于在行间编写事件处理</span><br><span class="hljs-comment">  &lt;div onclick = &quot;console.log(&#x27;点击了div&#x27;)&quot;&gt;点击了div&lt;/div&gt;  这种书写方式被称为 句柄</span><br><span class="hljs-comment">  执行环境:</span><br><span class="hljs-comment">    this 指向元素本身</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a><code>addEventListener()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// addEventListener(&#x27;事件类型&#x27;，处理函数, false) &#123;&#125;</span><br><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;demo&#x27;</span>);<br>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了div&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  能够给一个事件绑定多个处理函数(不能给同一个函数绑定多个事件),先绑定先执行</span><br><span class="hljs-comment">  IE9及以下不兼容</span><br><span class="hljs-comment">  执行环境:</span><br><span class="hljs-comment">    this 指向元素本身</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="attachEvent"><a href="#attachEvent" class="headerlink" title="attachEvent()"></a><code>attachEvent()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// attachEvent(&#x27;on&#x27; + 事件类型， 处理函数)</span><br>div.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  IE独有，和addEventListener类似，多个处理函数时先绑定后执行,同一个函数可以绑定多个事件</span><br><span class="hljs-comment">  执行环境:</span><br><span class="hljs-comment">    this 指向 window</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="绑定事件方法封装"><a href="#绑定事件方法封装" class="headerlink" title="绑定事件方法封装"></a>绑定事件方法封装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加事件处理函数</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">elem</span>&#125; DOM元素 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">type</span>&#125; 事件类型 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">handle</span>&#125; 事件处理函数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">elem, type, handle</span>) &#123;<br>  <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">addEventListener</span>) &#123;<br>    elem.<span class="hljs-title function_">addEventListener</span>(type, handle, <span class="hljs-literal">false</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">attachEvent</span>) &#123;<br>    elem.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;on&#x27;</span> + type, handle);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    elem[<span class="hljs-string">&#x27;on&#x27;</span> + type] = handle;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解除事件处理程序"><a href="#解除事件处理程序" class="headerlink" title="解除事件处理程序"></a>解除事件处理程序</h3><h4 id="onclick-1"><a href="#onclick-1" class="headerlink" title="onclick()"></a><code>onclick()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">elem.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; &#125;<br>elem.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// false / &quot;&quot; / null</span><br></code></pre></td></tr></table></figure><h4 id="addEventListener-1"><a href="#addEventListener-1" class="headerlink" title="addEventListener()"></a><code>addEventListener()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, test, <span class="hljs-literal">false</span>);<br>div.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, test, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 必须使用事件名来解除</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="attachEvent-1"><a href="#attachEvent-1" class="headerlink" title="attachEvent()"></a><code>attachEvent()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">elem.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&#x27;on&#x27;</span> + type, fn);<br></code></pre></td></tr></table></figure><h3 id="事件处理模型-事件冒泡-x2F-捕获"><a href="#事件处理模型-事件冒泡-x2F-捕获" class="headerlink" title="事件处理模型: 事件冒泡 &#x2F; 捕获"></a>事件处理模型: 事件冒泡 &#x2F; 捕获</h3><h4 id="1-事件冒泡模型"><a href="#1-事件冒泡模型" class="headerlink" title="1. 事件冒泡模型"></a>1. 事件冒泡模型</h4><blockquote><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡功能，即同一事件，自子元素冒泡向父元素。（自底向上）</p></blockquote><h5 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.wrapper</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.content</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.aside</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> wrapper = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;content&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> aside = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;aside&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript"></span><br><span class="language-javascript">    wrapper.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    content.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;content&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    aside.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aside&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-事件捕获模型"><a href="#2-事件捕获模型" class="headerlink" title="2. 事件捕获模型"></a>2. 事件捕获模型</h4><blockquote><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自底向上）<br>对象上的一个事件类型，只能存在一个事件模型，例如：冒泡 or 捕获</p></blockquote><h5 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.wrapper</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.content</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.aside</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> wrapper = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;content&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> aside = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;aside&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript"></span><br><span class="language-javascript">    wrapper.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">true</span>)</span><br><span class="language-javascript">    content.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;content&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">true</span>) </span><br><span class="language-javascript">    aside.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aside&#x27;</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 注意这里的第三个参数是 true</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 事件捕获正好是相反的，是由外而内依次触发事件</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ul><li>IE 上没有事件捕获</li><li>一个元素的一个事件类型一个事件处理函数只能存在一个模型</li><li>如果一个元素、一个事件类型、绑定了两个事件处理函数，则可以同时拥有事件冒泡模型和事件捕获模型，执行顺序是先捕获再冒泡</li><li>执行顺序: 捕获wrapper - 捕获content - 捕获中执行aside（这两个看代码的执行顺序）冒泡中执行aside - 冒泡content - 冒泡wrapper</li><li>不冒泡的事件类型<ol><li><code>focus</code></li><li><code>blur</code> </li><li><code>change</code></li><li><code>submit</code></li><li><code>reset</code></li><li><code>select</code></li></ol></li></ul><h4 id="取消冒泡和阻止默认事件"><a href="#取消冒泡和阻止默认事件" class="headerlink" title="取消冒泡和阻止默认事件"></a>取消冒泡和阻止默认事件</h4><ul><li><p>取消冒泡 </p><ol><li><p>W3C标准, IE9以下不支持</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;  <span class="hljs-comment">// “e”: 事件源对象后续补充</span><br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 取消冒泡事件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IE浏览器独有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// IE独有</span><br>&#125; <br></code></pre></td></tr></table></figure></li></ol></li><li><p>阻止默认事件</p><ol><li><p><code>return false;</code> 只能以句柄的方式绑定或<code>el.onclick = fn()</code>的事件才能生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 阻止默认事件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>event.preventDefault();</code> W3C标准， IE9以下不兼容</p></li><li><p><code>event.returnValue = false;</code> 兼容IE</p></li><li><p>协议限定符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 阻止 a 标签的默认事件<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void()&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="事件对象-x2F-事件源对象"><a href="#事件对象-x2F-事件源对象" class="headerlink" title="事件对象 &#x2F; 事件源对象"></a>事件对象 &#x2F; 事件源对象</h4><ul><li><p>事件对象</p><ul><li><p>处理函数可以传入一个形参 e，是系统传进来的 event对象</p><ol><li><code>event</code>: 普通浏览器</li><li><code>window.event</code>: IE!!!</li></ol></li><li><p>兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;  <span class="hljs-comment">// 获取事件对象方法的兼容</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>事件源对象</p><ul><li><p>事件源对象是执行而非捕获</p><ol><li><code>event.target</code>        : 火狐独有</li><li><code>event.srcElement</code> : IE独有</li><li>以上 Chrome 都有</li></ol></li><li><p>兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>利用事件冒泡和事件源对象进行处理</p><ul><li>优点<ol><li>性能 - 不需要循环所有的元素一个个绑定事件</li><li>灵活 - 当有新的子元素时不需要重新绑定事件</li></ol></li></ul><h5 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">    ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerText</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><ul><li><p>鼠标事件</p><table><thead><tr><th></th><th>事件名称</th><th>事件描述</th><th>事件类别</th><th></th></tr></thead><tbody><tr><td></td><td><code>click</code></td><td>在元素上按下并释放任意鼠标按键。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>contextmenu</code></td><td>右键点击</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>dblclick</code></td><td>在元素上双击鼠标按钮</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mousedown</code></td><td>在元素上按下任意鼠标按钮。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mouseup</code></td><td>在元素上释放任意鼠标按键。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mouseenter</code></td><td>指针移到有事件监听的元素内</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mouseleave</code></td><td>指针移出元素范围外(不冒泡 )</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mousemove</code></td><td>指针移入元素。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mouseover</code></td><td>指针移出元素</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>mouseout</code></td><td>指针移出元素，或者移到它的子元素上。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>pointerlockchange</code></td><td>鼠标被锁定或者解除锁定发生时。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>pointerlockerror</code></td><td>可能因为一些技术的原因鼠标锁定被禁止时。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>select</code></td><td>有文本被选中。</td><td>鼠标事件</td><td></td></tr><tr><td></td><td><code>wheel</code></td><td>滚轮向任意方向滚动。</td><td>鼠标事件</td><td></td></tr></tbody></table></li><li><p>区分鼠标的左右按键</p><ul><li><p><code>mousedown</code></p></li><li><p><code>mouseup</code></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">onmousedown</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123; <span class="hljs-comment">// 使用onmousedown || onmouseup</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">button</span>); <span class="hljs-comment">// 使用事件对象中的button属性来判断，左：0 中：1 右：2</span><br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">&gt; DOM3标准规定：click 事件只能监听左键，只能通过`mousedown`和`mouseup` 来判断鼠标键</code></pre></li></ul></li><li><p>键盘事件</p><ol><li><code>keydown</code>  : 键盘按下事件</li><li><code>keyup</code>    : 键盘抬起事件</li><li><code>keypress</code> : 键盘持续触发事件</li></ol><ul><li><p><code>keydown &gt; keypress &gt; keyup</code></p></li><li><p><code>keydown</code> 和 <code>keypress</code> 的区别：</p><ol><li><p><code>keydown</code> 可以响应任意键盘按键，</p></li><li><p><code>keypress</code> keypress只可以监听到字符类键盘按键,返回ASCII码，可以转换成相应字符</p></li></ol></li></ul></li><li><p>文本类事件</p><ol><li><p><code>input</code>  : 内容改变监听事件</p></li><li><p><code>change</code> : 聚焦和失焦时两个状态是否发生改变</p></li><li><p><code>focus</code>  : 元素聚焦</p></li><li><p><code>blur</code>   : 元素失焦</p></li></ol><ul><li><p>窗体类事件(window上的事件)</p><ol><li><code>scroll</code> : 滚动条滚动时触发</li><li><code>load</code>   : 文档解析并加载完成之后执行脚本（性能低，不推荐）</li></ol></li></ul></li></ul><hr><h2 id="40-浏览器渲染机制"><a href="#40-浏览器渲染机制" class="headerlink" title="40. 浏览器渲染机制"></a>40. 浏览器渲染机制</h2><blockquote><p>打开网页时浏览器首先识别 HTML 代码并行成 DOMTree，然后解析 CSS 形成 CSSTree，然后将 DOMTree 和 CSSTree 进行结合形成新的 RenderTree，然后浏览器会根据 RenderTree 绘制页面</p></blockquote><ul><li><p>浏览器资源加载顺序</p><ol><li><p>识别 html 代码进行解析，然后形成DOM树 <code>DOMTree</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  DOMTree:</span><br><span class="hljs-comment">            &lt;html&gt;</span><br><span class="hljs-comment">  &lt;head&gt;              &lt;body&gt;</span><br><span class="hljs-comment">                &lt;div&gt;  &lt;span&gt; &lt;stong&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">根据节点的所在位置绘制成一个树结构</span><br><span class="hljs-comment">DOMTree 绘制机制符合**深度优先**原则，直到某一条枝干上没有其他元素，才会更改枝干再进行绘制（解析绘制时不必等元素引用的资源加载完成）</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>CSSTree</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  DOMTree 创建完成之后，解析CSS并创建CSSTree</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>RenderTree</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">将 DOMTree 和 CSSTree 进行结合形成新的 RenderTree，然后浏览器会依据 RenderTree 进行绘制页面</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>重排 reflow</p><ul><li>DOM节点的添加、删除，DOM节点的宽高变化、位置变化，display、offsetWidth、offsetHeight 都会致使 RenderTree 重构，极大损耗了性能</li></ul></li><li><p>重绘 repaint</p><ul><li>修改字体颜色、背景颜色等等会触发重绘，它会致使 renderTree 部分改变，想对 reflow 会好很多</li></ul></li></ul><hr><h2 id="41-JSON"><a href="#41-JSON" class="headerlink" title="41. JSON"></a>41. JSON</h2><blockquote><p>JSON 是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的吗，json是用来传输的）</p></blockquote><p>常用方法</p><ul><li><code>JSON.stringify(json);</code>  转换成一个字符串</li><li><code>JSON.parse(字符串);</code>     转换成 JSON</li></ul><hr><h2 id="42-异步js加载"><a href="#42-异步js加载" class="headerlink" title="42. 异步js加载"></a>42. 异步js加载</h2><ul><li><p>js加载的缺点</p><blockquote><p>加载工具方法没必要阻塞文档，过得js加载会影响页面效率，一旦网速不好，那么整个网站等待js加载而不进行后续的渲染工作。   </p></blockquote></li><li><p>按需加载 </p><blockquote><p>有些工具方法需要按需加载，用到再加载，不用不加载</p><p>工具包(初始化数据，事件绑定)，不修改页面的可以异步加载进来</p></blockquote></li><li><p>JavaScript 异步加载的三种方案</p><ol><li><p>defer 异步加载，但要等到dom文档全部解析完才会被执行。只有IE能用，也可以将代码写到内部</p></li><li><p>async 异步加载，加载完就执行，async 只能加载外部脚本，不能把 js 写在 script 标签里</p></li><li><p>创建 script，插入到dom中，加载完毕后callback</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">url, callback</span>) &#123;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(script.<span class="hljs-property">readyState</span>) &#123;<br>        script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span>(script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;complete&#x27;</span> || script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;loaded&#x27;</span>) &#123;<br>                <span class="hljs-title function_">callback</span>();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">callback</span>();<br>        &#125;<br>    &#125;<br>    script.<span class="hljs-property">src</span> = url;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;../test/tools.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">check</span>();&#125;);<br></code></pre></td></tr></table></figure></li></ol></li></ul><hr><h2 id="43-浏览器加载时间线"><a href="#43-浏览器加载时间线" class="headerlink" title="43. 浏览器加载时间线"></a>43. 浏览器加载时间线</h2><ol><li><p>创建document对象，开始解析web页面。解析html元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段 document.readyState &#x3D; ‘loading’。</p></li><li><p>遇到link外部css，创建线程加载，并继续解读文档。</p></li><li><p>遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</p></li><li><p>遇到script外部js，并设置有async、defer，浏览器创建线程加载，并继续解读文档。对于async属性的脚本，脚本加载完后后立即执行。（异步禁止使用document.write() ）</p></li><li><p>遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解读文档。</p></li><li><p>当文档解读完成，document.readyState&#x3D;’interactive’。</p></li><li><p>当文档解析完成后，所有设置defer的脚本会按照顺序依次执行。（同样禁止document.write()）</p></li><li><p>document对象触发DOMContentLoaded事件，标志着程序从脚本同步执行阶段，转化为事件驱动阶段。</p></li><li><p>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState &#x3D; ‘complete’，window对象触发load事件</p></li><li><p>从此，以异步响应方式处理用户输入、网络事件等。</p></li></ol><hr><h2 id="44-RegExp-正则表达式"><a href="#44-RegExp-正则表达式" class="headerlink" title="44. RegExp 正则表达式"></a>44. RegExp 正则表达式</h2><blockquote><p>匹配特殊字符或有特殊搭配原则的字符的最佳选择。</p></blockquote><h3 id="学前补充-转义字符"><a href="#学前补充-转义字符" class="headerlink" title="学前补充(转义字符)"></a>学前补充(转义字符)</h3><ul><li><p>使用反斜杠进行转义，将转义符号后面的单位转义成文本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;ab\&quot;cd&quot;</span>; <br></code></pre></td></tr></table></figure></li><li><p>更多使用方式</p><ol><li><p><code>\n</code> : 换行</p></li><li><p><code>\r</code> : 行结束</p></li><li><p><code>\t</code> : 一个Table间隔</p></li></ol></li></ul><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><h4 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1. 字面量"></a>1. 字面量</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/abc/</span>;  <span class="hljs-comment">/* 要匹配的 /规则/  */</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// test() 方法是测试 这个字符串中是否符合这个标准</span><br></code></pre></td></tr></table></figure><h4 id="2-new-RegExp-构造函数"><a href="#2-new-RegExp-构造函数" class="headerlink" title="2. new RegExp() 构造函数;"></a>2. <code>new RegExp()</code> 构造函数;</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;规则&#x27;</span>); <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><ul><li>两种创建方式的区别</li></ul><ul><li><p>修饰符</p><ol><li><p><code>i</code>: 忽略大小写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/abc/i</span>;<br><span class="hljs-comment">// var reg = /abc/变量；</span><br></code></pre></td></tr></table></figure></li><li><p><code>g</code>: 匹配全局</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;ababab&#x27;</span>;<br><span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg)); <span class="hljs-comment">// 这样可以返回匹配到所以符合规则的值</span><br></code></pre></td></tr></table></figure></li><li><p><code>m</code> : 执行多行匹配(匹配的就是开头和结尾)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^a/gm</span>;  <span class="hljs-comment">// &quot;^a&quot; 表示开头必须是a</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abdc\na&#x27;</span>; <span class="hljs-comment">// “\n” 是换行</span><br><span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg)); <span class="hljs-comment">// [&#x27;a&#x27;],[&#x27;a&#x27;]</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h4><ol><li><code>reg.test(str);</code>:  str字符串中是否符合规则</li><li><code>str.match(reg);</code>: 返回符合规则的值</li></ol><h4 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4. 表达式"></a>4. 表达式</h4><h4 id="5-元字符"><a href="#5-元字符" class="headerlink" title="5. 元字符"></a>5. 元字符</h4><h4 id="6-文档链接"><a href="#6-文档链接" class="headerlink" title="6. 文档链接"></a>6. 文档链接</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li></ul><hr><h2 id="45-bind"><a href="#45-bind" class="headerlink" title="45. bind"></a>45. bind</h2><blockquote><p>bind方法用来绑定 this 指向。与call&amp;apply改变this指向有所不同。</p><p>call&amp;apply 数据执行时改变this。bind 是先给方法绑定，等到特定的时机执行。</p></blockquote><h5 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单对象编程</span><br><span class="hljs-keyword">var</span> list = &#123;<br>  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mess</span> = <span class="hljs-string">&quot;howie&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dom</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;debounce&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindEvent</span>();<br>  &#125;,<br>  <span class="hljs-title function_">bindEvent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this list</span><br>    <span class="hljs-comment">// call apply： 是使用在立即执行时，而 bind 绑定的 this 是需要在特定的时间节点执行，而不是当下</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dom</span>.<span class="hljs-property">onclick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">showMessage</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;,<br>  <span class="hljs-title function_">showMessage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">mess</span>);<br>  &#125;<br>&#125;<br><br>list.<span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="46-防抖-amp-节流"><a href="#46-防抖-amp-节流" class="headerlink" title="46. 防抖 &amp; 节流"></a>46. 防抖 &amp; 节流</h2><h4 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a>1. 防抖</h4><blockquote><p>在规定的时间内触发事件处理函数 1 次，如果未到规定时间内多次触发，会将时间清零，重新计算触发事件处理函数的时间，这样做可以避免服务器性能的过度消耗，优化页面请求性能。</p></blockquote><h5 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn, delay</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> tiemr = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(tiemr);<br>    tiemr = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;./data.json&#x27;</span>,<br>      <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>      <span class="hljs-title function_">success</span>(<span class="hljs-params">result</span>) &#123;<br>        <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取成功!&#x27;</span>, result);<br>      &#125;,<br>      <span class="hljs-title function_">error</span>(<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取失败&#x27;</span>, err);<br>      &#125;<br>    &#125;)<br>  &#125;<br><br><br><span class="hljs-keyword">const</span> oDebounce = <span class="hljs-title function_">debounce</span>(handleClick, <span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">let</span> debounceBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;debounce&#x27;</span>);<br>debounceBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, oDebounce, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h4 id="2-节流"><a href="#2-节流" class="headerlink" title="2. 节流"></a>2. 节流</h4><blockquote><p>在规定时间内触发事件处理函数 1 次，如果在未到处理时间，执行了多出触发，则忽略此次触发不予执行。优化网络请求性能。</p></blockquote><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn, delay</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span>;<br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  $.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;./data.json&#x27;</span>,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>    <span class="hljs-title function_">success</span>(<span class="hljs-params">data</span>) &#123;<br>      <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据获取成功&#x27;</span>, data);<br>    &#125;,<br>    <span class="hljs-title function_">error</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据获取失败&#x27;</span>, err);<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> oThrottle = <span class="hljs-title function_">throttle</span>(handleClick, <span class="hljs-number">2000</span>);<br><br><span class="hljs-keyword">let</span> throttleBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;throttle&#x27;</span>);<br>throttleBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, oThrottle, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="47-避免Bug思想利器-纯函数"><a href="#47-避免Bug思想利器-纯函数" class="headerlink" title="47. 避免Bug思想利器-纯函数"></a>47. 避免Bug思想利器-纯函数</h2><blockquote><p>纯函数的定义是，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。不依赖和修改其作用域之外变量的函数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
